00001117 // auipc sp, 0x1          ; _start: 设置 SP 高 20 位 (0x1000)
00010113 // addi  sp, sp, 0        ; 设置 SP 低 12 位 (SP = 0x1000)
008000ef // jal   ra, 0x08         ; 跳转到 main 函数 (地址 0x10)
00100073 // ebreak                 ; Stop Simulation (原为 j 0xc)
fe010113 // addi  sp, sp, -32      ; main: 开辟栈帧 (地址 0x10)
00812e23 // sw    s0, 28(sp)       ; 保存 s0
02010413 // addi  s0, sp, 32       ; 设置 s0
fe042623 // sw    zero, -20(s0)    ; i = 0
0540006f // j     0x64             ; 跳转到循环条件检查 (地址 0x64)
00000713 // li    a4, 0            ; <loop_body>: 数组 A 基址 0
fec42783 // lw    a5, -20(s0)      ; 加载 i
00279793 // slli  a5, a5, 2        ; i * 4
00f707b3 // add   a5, a4, a5       ; &A[i]
0007a703 // lw    a4, 0(a5)        ; 加载 A[i]
4b000693 // li    a3, 1200         ; 数组 B 基址 1200 (0x4B0)
fec42783 // lw    a5, -20(s0)      ; 加载 i
00279793 // slli  a5, a5, 2        ; i * 4
00f687b3 // add   a5, a3, a5       ; &B[i]
0007a783 // lw    a5, 0(a5)        ; 加载 B[i]
00f70733 // add   a4, a4, a5       ; A[i] + B[i]
000017b7 // lui   a5, 0x1          ; 数组 C 基址高 20 位 (0x1000)
96078693 // addi  a3, a5, -1696    ; 数组 C 基址 2400 (0x1000 - 0x6A0 = 0x960)
fec42783 // lw    a5, -20(s0)      ; 加载 i
00279793 // slli  a5, a5, 2        ; i * 4
00f687b3 // add   a5, a3, a5       ; &C[i]
00e7a023 // sw    a4, 0(a5)        ; C[i] = A[i] + B[i]
fec42783 // lw    a5, -20(s0)      ; 加载 i
00178793 // addi  a5, a5, 1        ; i++
fef42623 // sw    a5, -20(s0)      ; 更新 i
fec42703 // lw    a4, -20(s0)      ; <loop_cond>: 加载 i (地址 0x64)
12b00793 // li    a5, 299          ; limit = 299
fae7d4e3 // bge   a5, a4, 0x28     ; if (299 >= i) goto loop_body
000017b7 // lui   a5, 0x1          ; 数组 C 基址高 20 位
96078793 // addi  a5, a5, -1696    ; 数组 C 基址 2400
4ac7a783 // lw    a5, 1196(a5)     ; 加载 C[299] (验证用)
00078513 // mv    a0, a5           ; 设置返回值
01c12403 // lw    s0, 28(sp)       ; 恢复 s0
02010113 // addi  sp, sp, 32       ; 恢复 sp
00008067 // ret                    ; 返回
