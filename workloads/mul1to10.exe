00001117 // auipc sp, 0x1          ; _start: 设置 SP 高 20 位 (0x1000)
00010113 // addi  sp, sp, 0        ; 设置 SP 低 12 位 (SP = 0x1000)
008000ef // jal   ra, 0x08         ; 跳转到 main 函数 (地址 0x10)
0000006f // j     0x04             ; 跳转到自身 (停止模拟器)
fe010113 // addi  sp, sp, -32      ; main: 开辟栈帧 (地址 0x10)
00812e23 // sw    s0, 28(sp)       ; 保存 s0
02010413 // addi  s0, sp, 32       ; 设置 s0 (栈帧基址)
fe042623 // sw    zero, -20(s0)    ; i = 0 (循环变量初始化)
0300006f // j     0x38             ; 跳转到循环条件检查 (地址 0x54)
00000713 // li    a4, 0            ; <loop_body>: 设置数组基址为 0 (存储 1-10)
fec42783 // lw    a5, -20(s0)      ; 加载 i
00279793 // slli  a5, a5, 2        ; i * 4 (计算偏移量)
00f707b3 // add   a5, a4, a5       ; &array[i]
0007a703 // lw    a4, 0(a5)        ; 加载 array[i] (值为 i+1)
02802783 // lw    a5, 40(zero)     ; 加载累积结果 (地址 40)
02f70733 // mul   a4, a4, a5       ; RV32M 乘法: array[i] * 累积结果
02e02423 // sw    a4, 40(zero)     ; 保存新的累积结果到地址 40
fec42783 // lw    a5, -20(s0)      ; 加载 i
00178793 // addi  a5, a5, 1        ; i++
fef42623 // sw    a5, -20(s0)      ; 更新 i
fec42703 // lw    a4, -20(s0)      ; <loop_cond>: 加载 i
00900793 // li    a5, 9            ; limit = 9
fce7d6e3 // bge   a5, a4, -52      ; if (9 >= i) goto loop_body
02802783 // lw    a5, 40(zero)     ; 加载最终结果 (1*2*3*...*10)
00078513 // mv    a0, a5           ; 设置返回值
01c12403 // lw    s0, 28(sp)       ; 恢复 s0
02010113 // addi  sp, sp, 32       ; 恢复 sp
00008067 // ret                    ; 返回
