00001117 // auipc sp, 0x1          ; _start: 设置 SP 高 20 位 (0x1000)
00010113 // addi  sp, sp, 0        ; 设置 SP 低 12 位 (SP = 0x1000)
074000ef // jal   ra, 0x74         ; 跳转到 main 函数 (地址 0x7C)
00100073 // ebreak                 ; Stop Simulation (原为 j 0xc)
fd010113 // addi  sp, sp, -48      ; soft_mul: 开辟栈帧 (地址 0x10)
02812623 // sw    s0, 44(sp)       ; 保存 s0
03010413 // addi  s0, sp, 48       ; 设置 s0
fca42e23 // sw    a0, -36(s0)      ; 保存参数 a (被乘数)
fcb42c23 // sw    a1, -40(s0)      ; 保存参数 b (乘数)
fe042623 // sw    zero, -20(s0)    ; res = 0
0380006f // j     0x5c             ; 跳转到循环条件检查 (地址 0x4C)
fd842783 // lw    a5, -40(s0)      ; <loop_body>: 加载 b
0017f793 // andi  a5, a5, 1        ; b & 1
00078a63 // beqz  a5, 0x44         ; if (lowest bit is 0) skip add
fec42703 // lw    a4, -20(s0)      ; 加载 res
fdc42783 // lw    a5, -36(s0)      ; 加载 a
00f707b3 // add   a5, a4, a5       ; res + a
fef42623 // sw    a5, -20(s0)      ; 更新 res
fdc42783 // lw    a5, -36(s0)      ; <skip_add>: 加载 a
00179793 // slli  a5, a5, 1        ; a <<= 1
fcf42e23 // sw    a5, -36(s0)      ; 更新 a
fd842783 // lw    a5, -40(s0)      ; 加载 b
4017d793 // srai  a5, a5, 1        ; b >>= 1
fcf42c23 // sw    a5, -40(s0)      ; 更新 b
fd842783 // lw    a5, -40(s0)      ; <loop_cond>: 加载 b
fc0794e3 // bnez  a5, 0x28         ; if (b != 0) goto loop_body
fec42783 // lw    a5, -20(s0)      ; 加载 res
00078513 // mv    a0, a5           ; 设置返回值
02c12403 // lw    s0, 44(sp)       ; 恢复 s0
03010113 // addi  sp, sp, 48       ; 恢复 sp
00008067 // ret                    ; 返回
fe010113 // addi  sp, sp, -32      ; main: 开辟栈帧 (地址 0x7C)
00112e23 // sw    ra, 28(sp)       ; 保存 ra
00812c23 // sw    s0, 24(sp)       ; 保存 s0
02010413 // addi  s0, sp, 32       ; 设置 s0
fe042623 // sw    zero, -20(s0)    ; i = 0
05c0006f // j     0xe8             ; 跳转到计算循环检查 (地址 0xE8)
00000713 // li    a4, 0            ; <calc_loop>: 数组 A 基址 0
fec42783 // lw    a5, -20(s0)      ; 加载 i
00279793 // slli  a5, a5, 2        ; i * 4
00f707b3 // add   a5, a4, a5       ; &A[i]
0007a683 // lw    a3, 0(a5)        ; 加载 A[i]
19000713 // li    a4, 400          ; 数组 B 基址 400 (0x190)
fec42783 // lw    a5, -20(s0)      ; 加载 i
00279793 // slli  a5, a5, 2        ; i * 4
00f707b3 // add   a5, a4, a5       ; &B[i]
0007a783 // lw    a5, 0(a5)        ; 加载 B[i]
00078593 // mv    a1, a5           ; 参数 b = B[i]
00068513 // mv    a0, a3           ; 参数 a = A[i]
f4dff0ef // jal   ra, 0x10         ; call soft_mul (地址 0x10)
00050693 // mv    a3, a0           ; 获取结果 result
32000713 // li    a4, 800          ; 数组 C 基址 800 (0x320)
fec42783 // lw    a5, -20(s0)      ; 加载 i
00279793 // slli  a5, a5, 2        ; i * 4
00f707b3 // add   a5, a4, a5       ; &C[i]
00d7a023 // sw    a3, 0(a5)        ; C[i] = result
fec42783 // lw    a5, -20(s0)      ; 加载 i
00178793 // addi  a5, a5, 1        ; i++
fef42623 // sw    a5, -20(s0)      ; 更新 i
fec42703 // lw    a4, -20(s0)      ; <calc_check>: 加载 i (地址 0xE8)
06300793 // li    a5, 99           ; limit = 99
fae7d0e3 // bge   a5, a4, 0x98     ; if (99 >= i) goto calc_loop
32000793 // li    a5, 800          ; 数组 C 基址
18c7a783 // lw    a5, 396(a5)      ; 加载 C[99] (验证用)
00078513 // mv    a0, a5           ; 设置返回值
01c12083 // lw    ra, 28(sp)       ; 恢复 ra
01812403 // lw    s0, 24(sp)       ; 恢复 s0
02010113 // addi  sp, sp, 32       ; 恢复 sp
00008067 // ret                    ; 返回