# Assassyn CPU 内存初始化报告

## 概述

本报告描述了如何使用 `accumulate_data.bin` 和 `accumulate_text.bin` 文件初始化 Assassyn CPU 的主内存（main_memory）和指令缓存（icache）。

### Accumulate 程序简介

`accumulate` 是一个简单的累加测试程序，用于验证 CPU 的基本功能：
- **功能**: 计算从1到100的累加和（1+2+3+...+100 = 5050）
- **指令数**: 22条 RISC-V 指令
- **数据段**: 无需静态数据初始化（使用栈和寄存器）
- **测试目标**: 验证算术运算、循环控制、内存访问等基本功能

## 文件说明

### 输入文件

- **`accumulate_data.bin`**: 数据段二进制文件
  - 格式：原始二进制数据
  - 字节序：小端序（Little-Endian）
  - 字宽：32位（4字节）对齐
  - 用途：初始化 CPU 的数据内存（main_memory）
  - **当前状态**: 空文件（0字节），表示 accumulate 程序不需要初始化的数据段

- **`accumulate_text.bin`**: 指令段二进制文件
  - 格式：原始二进制指令
  - 字节序：小端序（Little-Endian）
  - 字宽：32位 RISC-V 指令
  - 用途：初始化 CPU 的指令缓存（icache）
  - **当前大小**: 88字节（22条指令）

### 输出文件

- **`.workspace/workload_mem.exe`**: 数据内存初始化文件
  - 格式：ASCII 十六进制文本
  - 每行一个32位字（8个十六进制数字）
  - 从 `data.bin` 转换而来

- **`.workspace/workload_ins.exe`**: 指令内存初始化文件
  - 格式：ASCII 十六进制文本
  - 每行一个32位指令（8个十六进制数字）
  - 从 `text.bin` 转换而来

- **`.workspace/workload.init`**: 偏移量初始化文件
  - 包含初始偏移值（通常为 0）

## 初始化流程

### 步骤 1: 准备二进制文件

确保在 `main_test/` 目录下有以下文件：
- `accumulate_data.bin` - 数据段（accumulate 程序的数据段）
- `accumulate_text.bin` - 指令段（accumulate 程序的指令段）

**注意**: 这两个文件已经在 `main_test/` 目录中准备好了。

#### 示例：创建测试数据

```python
import struct

# 创建示例数据段 (data.bin)
data_values = [
    0x00000000,  # 地址 0
    0x12345678,  # 地址 4
    0xDEADBEEF,  # 地址 8
    0xCAFEBABE,  # 地址 12
]

with open('data.bin', 'wb') as f:
    for value in data_values:
        f.write(struct.pack('<I', value))  # 小端序32位整数

# 创建示例指令段 (text.bin)
instructions = [
    0x00000013,  # addi x0, x0, 0  (NOP)
    0x00100093,  # addi x1, x0, 1
    0x00200113,  # addi x2, x0, 2
    0x002081B3,  # add  x3, x1, x2
]

with open('text.bin', 'wb') as f:
    for instr in instructions:
        f.write(struct.pack('<I', instr))
```

### 步骤 2: 运行转换脚本

使用提供的转换脚本将二进制文件转换为 Assassyn SRAM 初始化格式：

```bash
cd main_test
python3 convert_bin_to_exe.py
```

#### 转换过程说明

转换脚本执行以下操作：

1. **读取二进制文件**: 以二进制模式读取 `.bin` 文件
2. **解析32位字**: 按小端序解析每个32位字
3. **生成十六进制文本**: 将每个字转换为8位十六进制数（无 `0x` 前缀）
4. **写入 .exe 文件**: 每行一个值，保存到 `.workspace/` 目录
5. **创建目录**: 自动创建 `.workspace/` 目录（如果不存在）

#### 实际输出（accumulate 程序）

```
======================================================================
Assassyn CPU Memory Initialization Converter
======================================================================

📁 Workspace directory: /home/runner/work/Assassyn-CPU/Assassyn-CPU/.workspace

✅ Converted Data Memory (accumulate_data.bin → workload_mem.exe):
   Input:  accumulate_data.bin (0 bytes, 0 words)
   Output: .workspace/workload_mem.exe

✅ Converted Instruction Memory (accumulate_text.bin → workload_ins.exe):
   Input:  accumulate_text.bin (88 bytes, 22 words)
   Output: .workspace/workload_ins.exe
   First few values: 0xfe010113 0x00812e23 0x02010413 0xfe042423 

✅ Created initialization file: .workspace/workload.init

======================================================================
✅ Conversion completed successfully!
======================================================================
```

**说明**: 
- `accumulate_data.bin` 为空（0字节），说明该程序不需要预初始化的静态数据
- `accumulate_text.bin` 包含22条 RISC-V 指令（88字节）

### 步骤 3: 验证生成的文件

检查 `.workspace/` 目录下的文件：

```bash
ls -l ../.workspace/
cat ../.workspace/workload_mem.exe
cat ../.workspace/workload_ins.exe
```

#### Accumulate 程序的实际文件内容

**workload_ins.exe** (指令内存 - 22条指令):
```
fe010113    # 地址 0x00: addi sp, sp, -32     (设置栈帧)
00812e23    # 地址 0x04: sw   s0, 28(sp)      (保存 s0)
02010413    # 地址 0x08: addi s0, sp, 32      (设置帧指针)
fe042423    # 地址 0x0C: sw   zero, -24(s0)   (初始化 sum = 0)
00100793    # 地址 0x10: addi a5, zero, 1     (初始化 i = 1)
fef42623    # 地址 0x14: sw   a5, -20(s0)     (存储 i)
0200006f    # 地址 0x18: jal  zero, 32        (跳转到循环体)
fe842703    # 地址 0x1C: lw   a4, -24(s0)     (加载 sum)
fec42783    # 地址 0x20: lw   a5, -20(s0)     (加载 i)
00f707b3    # 地址 0x24: add  a5, a4, a5      (sum = sum + i)
fef42423    # 地址 0x28: sw   a5, -24(s0)     (存储 sum)
fec42783    # 地址 0x2C: lw   a5, -20(s0)     (加载 i)
00178793    # 地址 0x30: addi a5, a5, 1       (i = i + 1)
fef42623    # 地址 0x34: sw   a5, -20(s0)     (存储 i)
fec42703    # 地址 0x38: lw   a4, -20(s0)     (加载 i)
06400793    # 地址 0x3C: addi a5, zero, 100   (设置循环上限)
fce7dee3    # 地址 0x40: bge  a5, a4, -36     (如果 i <= 100, 继续循环)
00000793    # 地址 0x44: addi a5, zero, 0     (返回值 = 0)
00078513    # 地址 0x48: addi a0, a5, 0       (设置返回寄存器)
01c12403    # 地址 0x4C: lw   s0, 28(sp)      (恢复 s0)
02010113    # 地址 0x50: addi sp, sp, 32      (恢复栈指针)
00008067    # 地址 0x54: jalr zero, 0(ra)     (返回)
```

**workload_mem.exe** (数据内存 - 空):
```
(空文件 - accumulate 程序不需要预初始化的数据段)
```

**说明**: 
- 指令以小端序存储（每条指令4字节）
- 地址为字地址（每个地址对应一个32位字）
- 程序从地址 0x00 开始执行
- 程序使用栈来存储局部变量（sum 和 i）

### 步骤 4: 运行 CPU 仿真

转换完成后，可以直接运行 CPU 仿真：

```bash
cd ..
python src/main.py
```

CPU 会自动从以下位置加载初始化文件：
- 数据内存: `.workspace/workload_mem.exe`
- 指令内存: `.workspace/workload_ins.exe`
- 偏移初始化: `.workspace/workload.init`

## CPU 内存初始化原理

### main.py 中的初始化代码

```python
# 在 src/main.py 的 build_cpu() 函数中：

# 数据内存初始化
main_memory = SRAM(
    width=32, 
    depth=1 << depth_log, 
    init_file=f"{workspace}/workload_mem.exe"  # 从 data.bin 转换而来
)

# 指令缓存初始化
icache = SRAM(
    width=32, 
    depth=1 << depth_log, 
    init_file=f"{workspace}/workload_ins.exe"  # 从 text.bin 转换而来
)
```

### 内存映射

- **地址宽度**: 可配置（默认 `depth_log=16`，即 2^16 = 64K 字）
- **数据宽度**: 32位
- **地址空间**: 
  - 指令内存 (icache): 0x00000000 - 0x0000FFFF (字地址)
  - 数据内存 (main_memory): 0x00000000 - 0x0000FFFF (字地址)
- **字节序**: 小端序（Little-Endian）
- **对齐**: 32位字对齐（地址按4字节对齐）

### SRAM 初始化机制

Assassyn SRAM 的 `init_file` 参数接受以下格式：
- 纯文本文件
- 每行一个十六进制值（不带 `0x` 前缀）
- 值按顺序对应内存地址 0, 1, 2, ...
- 格式：`%08x` (8位十六进制，前导零填充)

## 文件格式详解

### 二进制文件格式 (.bin)

- **字节顺序**: 小端序（LSB first）
- **数据类型**: 无符号32位整数
- **对齐要求**: 必须是4字节的倍数

#### 示例：数值 0x12345678 在文件中的表示
```
偏移量: 00 01 02 03
字节:   78 56 34 12  (小端序)
```

### 初始化文件格式 (.exe)

- **编码**: ASCII 文本
- **每行格式**: `%08x\n` (8位小写十六进制 + 换行)
- **行数**: 等于内存字数
- **注释**: 不支持注释

#### 示例
```
00000013    # 第一个字 (地址 0)
00100093    # 第二个字 (地址 1)
00200113    # 第三个字 (地址 2)
```

## 如何使用 Accumulate 程序

### 当前 Accumulate 程序的生成方式

本项目中的 `accumulate_text.bin` 和 `accumulate_data.bin` 是从 RISC-V 汇编程序编译而来：

```bash
# 编译汇编代码（假设源文件为 accumulate.s）
riscv32-unknown-elf-as -march=rv32i -mabi=ilp32 -o accumulate.o accumulate.s

# 链接生成 ELF 文件
riscv32-unknown-elf-ld -Ttext 0x0 -o accumulate.elf accumulate.o

# 提取 .text 段（指令段）
riscv32-unknown-elf-objcopy -O binary -j .text accumulate.elf accumulate_text.bin

# 提取 .data 段（数据段）
riscv32-unknown-elf-objcopy -O binary -j .data accumulate.elf accumulate_data.bin
```

### 使用其他测试程序

如果需要测试其他程序，可以：

#### 方法 1: 手动创建二进制文件

使用 Python 脚本创建自定义的 `.bin` 文件：

```python
import struct

# 自定义数据段
data = [0x11111111, 0x22222222, 0x33333333]

with open('my_data.bin', 'wb') as f:
    for value in data:
        f.write(struct.pack('<I', value))

# 自定义指令段（示例：简单的 NOP 和加法）
instructions = [
    0x00000013,  # addi x0, x0, 0  (NOP)
    0x00100093,  # addi x1, x0, 1
    0x00200113,  # addi x2, x0, 2
    0x002081B3,  # add  x3, x1, x2
]

with open('my_text.bin', 'wb') as f:
    for instr in instructions:
        f.write(struct.pack('<I', instr))
```

#### 方法 2: 从 C/汇编程序生成

如果有 RISC-V 工具链，可以编译 C 或汇编程序：

```bash
# 从 C 程序编译
riscv32-unknown-elf-gcc -march=rv32i -mabi=ilp32 -nostdlib -o program.elf program.c

# 或从汇编编译
riscv32-unknown-elf-as -march=rv32i -mabi=ilp32 -o program.o program.s
riscv32-unknown-elf-ld -Ttext 0x0 -o program.elf program.o

# 提取 .text 段
riscv32-unknown-elf-objcopy -O binary -j .text program.elf text.bin

# 提取 .data 段（如果有）
riscv32-unknown-elf-objcopy -O binary -j .data program.elf data.bin
```

### 方法 3: 直接修改 .exe 文件

也可以直接创建或编辑 `.workspace/workload_*.exe` 文件：

```bash
# 创建简单的指令序列
cat > .workspace/workload_ins.exe << EOF
00000013
00100093
00200113
EOF
```

## 故障排除

### 问题 1: 文件大小不是4的倍数

**错误**: `.bin` 文件大小不是4字节的倍数

**解决方案**: 转换脚本会自动填充零字节对齐。或者手动确保文件大小正确：

```python
# 检查并填充
import os
size = os.path.getsize('data.bin')
if size % 4 != 0:
    with open('data.bin', 'ab') as f:
        f.write(b'\x00' * (4 - size % 4))
```

### 问题 2: 字节序错误

**症状**: 数据读取不正确，值看起来是反的

**原因**: 字节序不匹配

**解决方案**: 
- CPU 使用小端序（Little-Endian）
- 确保使用 `'<I'` 格式（小端无符号整数）
- 如果数据是大端序，转换时使用 `'>I'`

### 问题 3: .workspace 目录不存在

**错误**: 找不到 `.workspace` 目录

**解决方案**:
```bash
mkdir -p .workspace
```

或运行转换脚本，它会自动创建目录。

### 问题 4: 内存溢出

**症状**: 数据或指令超过内存大小

**解决方案**: 
- 检查 `depth_log` 参数（默认为16，即64K字）
- 如果需要更大内存，修改 `src/main.py` 中的 `depth_log` 参数
- 确保 `.bin` 文件大小不超过 `(1 << depth_log) * 4` 字节

### 问题 5: 权限错误

**错误**: 无法写入文件

**解决方案**:
```bash
chmod +x convert_bin_to_exe.py
chmod -R u+w .workspace
```

## 完整工作流示例 - Accumulate 程序

以下是使用 accumulate 程序的完整工作流：

```bash
# 1. 进入项目目录
cd Assassyn-CPU

# 2. 进入测试目录（accumulate_data.bin 和 accumulate_text.bin 已准备好）
cd main_test

# 3. 验证二进制文件存在
ls -lh accumulate_*.bin

# 输出示例：
# -rw-rw-r-- 1 user user  0 Dec 13 06:39 accumulate_data.bin
# -rw-rw-r-- 1 user user 88 Dec 13 06:39 accumulate_text.bin

# 4. 转换为 Assassyn SRAM 初始化格式
python3 convert_bin_to_exe.py

# 输出：
# ======================================================================
# Assassyn CPU Memory Initialization Converter
# ======================================================================
# 
# 📁 Workspace directory: /path/to/.workspace
# 
# ✅ Converted Data Memory (accumulate_data.bin → workload_mem.exe):
#    Input:  accumulate_data.bin (0 bytes, 0 words)
#    Output: .workspace/workload_mem.exe
# 
# ✅ Converted Instruction Memory (accumulate_text.bin → workload_ins.exe):
#    Input:  accumulate_text.bin (88 bytes, 22 words)
#    Output: .workspace/workload_ins.exe
#    First few values: 0xfe010113 0x00812e23 0x02010413 0xfe042423
# 
# ✅ Created initialization file: .workspace/workload.init
# ======================================================================

# 5. 验证转换结果
python3 verify_conversion.py

# 输出：
# ======================================================================
# Assassyn CPU Memory Initialization - Verification
# ======================================================================
# 
# ✅ Data Memory (accumulate_data.bin → workload_mem.exe): Verification passed! (0 words)
# ✅ Instruction Memory (accumulate_text.bin → workload_ins.exe): Verification passed! (22 words)
# 
# ======================================================================
# ✅ All verifications passed!
# ======================================================================

# 6. 查看生成的初始化文件
cat ../.workspace/workload_ins.exe

# 7. 运行 CPU 仿真（CPU 会自动加载初始化文件）
cd ..
python src/main.py

# 8. 可选：运行相关测试
pytest tests/test_fetch.py -v
```

### 预期结果

运行 accumulate 程序后，CPU 应该：
1. 从地址 0x00 开始执行指令
2. 初始化栈帧和变量
3. 执行循环累加（1到100）
4. 最终在某个寄存器或内存位置得到结果 5050 (0x13BA)
5. 正常返回

## 技术细节

### SRAM 初始化时序

1. **构建阶段**: `build_cpu()` 函数创建 SRAM 实例
2. **初始化时机**: Assassyn 后端在生成仿真器时读取 `init_file`
3. **数据加载**: 仿真器启动时将数据加载到内存数组
4. **访问**: CPU 通过地址总线访问初始化的数据

### 内存访问模式

```python
# 在 src/fetch.py 中访问 icache:
sram_addr = (pc_reg[0]) >> UInt(32)(2)  # PC 除以4得到字地址
icache.build(
    we=Bits(1)(0),      # 写使能=0 (读取)
    re=Bits(1)(1),      # 读使能=1
    addr=sram_addr,     # 地址
    wdata=Bits(32)(0)   # 写数据（读取时忽略）
)
```

### 地址计算

- **字节地址到字地址**: `word_addr = byte_addr >> 2` (除以4)
- **字地址到字节地址**: `byte_addr = word_addr << 2` (乘以4)

例如：
- PC = 0x00000000 → SRAM 地址 = 0 → 第一条指令
- PC = 0x00000004 → SRAM 地址 = 1 → 第二条指令
- PC = 0x00000008 → SRAM 地址 = 2 → 第三条指令

## 进阶使用

### 大型程序加载

对于更大的程序：

```python
# 批量生成指令
instructions = []
for i in range(1024):
    instructions.append(0x00000013)  # NOP

with open('text.bin', 'wb') as f:
    for instr in instructions:
        f.write(struct.pack('<I', instr))
```

### 从 ELF 文件提取

```bash
# 使用 objcopy 提取段
riscv32-unknown-elf-objcopy -O binary --only-section=.text program.elf text.bin
riscv32-unknown-elf-objcopy -O binary --only-section=.data program.elf data.bin
```

### 调试技巧

```python
# 在转换后添加验证
def verify_conversion(bin_file, exe_file):
    import struct
    
    # 读取原始二进制
    with open(bin_file, 'rb') as f:
        bin_data = f.read()
    
    # 读取转换后的十六进制
    with open(exe_file, 'r') as f:
        exe_data = [int(line.strip(), 16) for line in f]
    
    # 比较
    for i in range(len(bin_data) // 4):
        orig = struct.unpack('<I', bin_data[i*4:(i+1)*4])[0]
        conv = exe_data[i]
        assert orig == conv, f"Mismatch at word {i}: {orig:08x} != {conv:08x}"
    
    print(f"✅ Verification passed for {bin_file}")

verify_conversion('data.bin', '../.workspace/workload_mem.exe')
verify_conversion('text.bin', '../.workspace/workload_ins.exe')
```

## 参考资料

### 相关文件
- `src/main.py` - CPU 构建和内存初始化
- `src/fetch.py` - 指令读取（icache 访问）
- `src/memory.py` - 数据访问（main_memory 访问）
- `tests/common.py` - 测试工具和 SRAM 初始化辅助函数

### RISC-V 指令格式
- RV32I 基础指令集
- 32位指令字
- 小端序编码

### Assassyn 文档
- Assassyn HDL 语法
- SRAM 模块使用
- 仿真器配置

## 总结

通过本报告提供的方法，您可以：

1. ✅ 使用 `accumulate_data.bin` 初始化数据内存（main_memory）
2. ✅ 使用 `accumulate_text.bin` 初始化指令缓存（icache）
3. ✅ 自动转换二进制文件为 Assassyn SRAM 格式
4. ✅ 验证和调试内存初始化过程
5. ✅ 运行完整的 CPU 仿真

### 关键文件说明

**测试程序文件（main_test/）**:
- `accumulate_data.bin` - 数据段（0字节，无静态数据）
- `accumulate_text.bin` - 指令段（88字节，22条 RISC-V 指令）

**转换工具（main_test/）**:
- `convert_bin_to_exe.py` - 将 .bin 转换为 .exe 格式
- `verify_conversion.py` - 验证转换正确性

**生成的初始化文件（.workspace/）**:
- `workload_mem.exe` - 数据内存初始化文件
- `workload_ins.exe` - 指令内存初始化文件
- `workload.init` - 偏移量初始化文件

**CPU 使用**:
- 运行 `python src/main.py` 时，CPU 会自动从 `.workspace/` 加载这些文件
- CPU 的 `main_memory` 和 `icache` 会被正确初始化

### Accumulate 程序测试要点

- **程序功能**: 计算 1+2+3+...+100 = 5050
- **指令数量**: 22条
- **测试内容**: 
  - ✅ 指令获取（Fetch）
  - ✅ 指令解码（Decode）
  - ✅ 算术运算（ADD, ADDI）
  - ✅ 内存访问（LW, SW）
  - ✅ 分支跳转（JAL, BGE）
  - ✅ 循环控制
  - ✅ 栈帧管理

---

**报告生成日期**: 2025-12-13  
**CPU 架构**: RV32I 五级流水线  
**HDL**: Assassyn  
**测试程序**: Accumulate (1+2+...+100)  
**工具版本**: Python 3.10+  
**初始化状态**: ✅ 已完成
