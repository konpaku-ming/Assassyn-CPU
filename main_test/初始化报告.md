# Assassyn CPU 内存初始化报告

## 概述

本报告描述了如何使用 `data.bin` 和 `text.bin` 文件初始化 Assassyn CPU 的主内存（main_memory）和指令缓存（icache）。

## 文件说明

### 输入文件

- **`data.bin`**: 数据段二进制文件
  - 格式：原始二进制数据
  - 字节序：小端序（Little-Endian）
  - 字宽：32位（4字节）对齐
  - 用途：初始化 CPU 的数据内存（main_memory）

- **`text.bin`**: 指令段二进制文件
  - 格式：原始二进制指令
  - 字节序：小端序（Little-Endian）
  - 字宽：32位 RISC-V 指令
  - 用途：初始化 CPU 的指令缓存（icache）

### 输出文件

- **`.workspace/workload_mem.exe`**: 数据内存初始化文件
  - 格式：ASCII 十六进制文本
  - 每行一个32位字（8个十六进制数字）
  - 从 `data.bin` 转换而来

- **`.workspace/workload_ins.exe`**: 指令内存初始化文件
  - 格式：ASCII 十六进制文本
  - 每行一个32位指令（8个十六进制数字）
  - 从 `text.bin` 转换而来

- **`.workspace/workload.init`**: 偏移量初始化文件
  - 包含初始偏移值（通常为 0）

## 初始化流程

### 步骤 1: 准备二进制文件

确保在 `main_test/` 目录下有以下文件：
- `data.bin` - 数据段
- `text.bin` - 指令段

#### 示例：创建测试数据

```python
import struct

# 创建示例数据段 (data.bin)
data_values = [
    0x00000000,  # 地址 0
    0x12345678,  # 地址 4
    0xDEADBEEF,  # 地址 8
    0xCAFEBABE,  # 地址 12
]

with open('data.bin', 'wb') as f:
    for value in data_values:
        f.write(struct.pack('<I', value))  # 小端序32位整数

# 创建示例指令段 (text.bin)
instructions = [
    0x00000013,  # addi x0, x0, 0  (NOP)
    0x00100093,  # addi x1, x0, 1
    0x00200113,  # addi x2, x0, 2
    0x002081B3,  # add  x3, x1, x2
]

with open('text.bin', 'wb') as f:
    for instr in instructions:
        f.write(struct.pack('<I', instr))
```

### 步骤 2: 运行转换脚本

使用提供的转换脚本将二进制文件转换为 Assassyn SRAM 初始化格式：

```bash
cd main_test
python3 convert_bin_to_exe.py
```

#### 转换过程说明

转换脚本执行以下操作：

1. **读取二进制文件**: 以二进制模式读取 `.bin` 文件
2. **解析32位字**: 按小端序解析每个32位字
3. **生成十六进制文本**: 将每个字转换为8位十六进制数（无 `0x` 前缀）
4. **写入 .exe 文件**: 每行一个值，保存到 `.workspace/` 目录
5. **创建目录**: 自动创建 `.workspace/` 目录（如果不存在）

#### 预期输出

```
======================================================================
Assassyn CPU Memory Initialization Converter
======================================================================

📁 Workspace directory: /path/to/.workspace

✅ Converted Data Memory (data.bin → workload_mem.exe):
   Input:  data.bin (32 bytes, 8 words)
   Output: .workspace/workload_mem.exe
   First few values: 0x00000000 0x12345678 0xdeadbeef 0xcafebabe 

✅ Converted Instruction Memory (text.bin → workload_ins.exe):
   Input:  text.bin (32 bytes, 8 words)
   Output: .workspace/workload_ins.exe
   First few values: 0x00000013 0x00100093 0x00200113 0x002081b3 

✅ Created initialization file: .workspace/workload.init

======================================================================
✅ Conversion completed successfully!
======================================================================
```

### 步骤 3: 验证生成的文件

检查 `.workspace/` 目录下的文件：

```bash
ls -l ../.workspace/
cat ../.workspace/workload_mem.exe
cat ../.workspace/workload_ins.exe
```

#### 文件格式示例

**workload_ins.exe** (指令内存):
```
00000013
00100093
00200113
002081b3
40208233
002092b3
00312333
0030e3b3
```

**workload_mem.exe** (数据内存):
```
00000000
12345678
deadbeef
cafebabe
00000001
00000002
00000003
ffffffff
```

### 步骤 4: 运行 CPU 仿真

转换完成后，可以直接运行 CPU 仿真：

```bash
cd ..
python src/main.py
```

CPU 会自动从以下位置加载初始化文件：
- 数据内存: `.workspace/workload_mem.exe`
- 指令内存: `.workspace/workload_ins.exe`
- 偏移初始化: `.workspace/workload.init`

## CPU 内存初始化原理

### main.py 中的初始化代码

```python
# 在 src/main.py 的 build_cpu() 函数中：

# 数据内存初始化
main_memory = SRAM(
    width=32, 
    depth=1 << depth_log, 
    init_file=f"{workspace}/workload_mem.exe"  # 从 data.bin 转换而来
)

# 指令缓存初始化
icache = SRAM(
    width=32, 
    depth=1 << depth_log, 
    init_file=f"{workspace}/workload_ins.exe"  # 从 text.bin 转换而来
)
```

### 内存映射

- **地址宽度**: 可配置（默认 `depth_log=16`，即 2^16 = 64K 字）
- **数据宽度**: 32位
- **地址空间**: 
  - 指令内存 (icache): 0x00000000 - 0x0000FFFF (字地址)
  - 数据内存 (main_memory): 0x00000000 - 0x0000FFFF (字地址)
- **字节序**: 小端序（Little-Endian）
- **对齐**: 32位字对齐（地址按4字节对齐）

### SRAM 初始化机制

Assassyn SRAM 的 `init_file` 参数接受以下格式：
- 纯文本文件
- 每行一个十六进制值（不带 `0x` 前缀）
- 值按顺序对应内存地址 0, 1, 2, ...
- 格式：`%08x` (8位十六进制，前导零填充)

## 文件格式详解

### 二进制文件格式 (.bin)

- **字节顺序**: 小端序（LSB first）
- **数据类型**: 无符号32位整数
- **对齐要求**: 必须是4字节的倍数

#### 示例：数值 0x12345678 在文件中的表示
```
偏移量: 00 01 02 03
字节:   78 56 34 12  (小端序)
```

### 初始化文件格式 (.exe)

- **编码**: ASCII 文本
- **每行格式**: `%08x\n` (8位小写十六进制 + 换行)
- **行数**: 等于内存字数
- **注释**: 不支持注释

#### 示例
```
00000013    # 第一个字 (地址 0)
00100093    # 第二个字 (地址 1)
00200113    # 第三个字 (地址 2)
```

## 自定义数据

### 方法 1: 手动创建二进制文件

使用 Python 脚本创建自定义的 `.bin` 文件：

```python
import struct

# 自定义数据
data = [0x11111111, 0x22222222, 0x33333333]

with open('data.bin', 'wb') as f:
    for value in data:
        f.write(struct.pack('<I', value))
```

### 方法 2: 从汇编生成

如果有 RISC-V 汇编程序，可以使用工具链生成：

```bash
# 编译汇编代码
riscv32-unknown-elf-as -o program.o program.s

# 链接生成 ELF 文件
riscv32-unknown-elf-ld -Ttext 0x0 -o program.elf program.o

# 提取 .text 段
riscv32-unknown-elf-objcopy -O binary -j .text program.elf text.bin

# 提取 .data 段
riscv32-unknown-elf-objcopy -O binary -j .data program.elf data.bin
```

### 方法 3: 直接修改 .exe 文件

也可以直接创建或编辑 `.workspace/workload_*.exe` 文件：

```bash
# 创建简单的指令序列
cat > .workspace/workload_ins.exe << EOF
00000013
00100093
00200113
EOF
```

## 故障排除

### 问题 1: 文件大小不是4的倍数

**错误**: `.bin` 文件大小不是4字节的倍数

**解决方案**: 转换脚本会自动填充零字节对齐。或者手动确保文件大小正确：

```python
# 检查并填充
import os
size = os.path.getsize('data.bin')
if size % 4 != 0:
    with open('data.bin', 'ab') as f:
        f.write(b'\x00' * (4 - size % 4))
```

### 问题 2: 字节序错误

**症状**: 数据读取不正确，值看起来是反的

**原因**: 字节序不匹配

**解决方案**: 
- CPU 使用小端序（Little-Endian）
- 确保使用 `'<I'` 格式（小端无符号整数）
- 如果数据是大端序，转换时使用 `'>I'`

### 问题 3: .workspace 目录不存在

**错误**: 找不到 `.workspace` 目录

**解决方案**:
```bash
mkdir -p .workspace
```

或运行转换脚本，它会自动创建目录。

### 问题 4: 内存溢出

**症状**: 数据或指令超过内存大小

**解决方案**: 
- 检查 `depth_log` 参数（默认为16，即64K字）
- 如果需要更大内存，修改 `src/main.py` 中的 `depth_log` 参数
- 确保 `.bin` 文件大小不超过 `(1 << depth_log) * 4` 字节

### 问题 5: 权限错误

**错误**: 无法写入文件

**解决方案**:
```bash
chmod +x convert_bin_to_exe.py
chmod -R u+w .workspace
```

## 完整工作流示例

以下是完整的从源代码到运行的工作流：

```bash
# 1. 进入项目目录
cd Assassyn-CPU

# 2. 准备二进制文件（使用 Python 生成示例）
cd main_test
python3 << 'EOF'
import struct

# 数据段
with open('data.bin', 'wb') as f:
    for i in range(16):
        f.write(struct.pack('<I', i * 0x1000))

# 指令段（NOP 指令）
with open('text.bin', 'wb') as f:
    for i in range(16):
        f.write(struct.pack('<I', 0x00000013))
EOF

# 3. 转换为 Assassyn 格式
python3 convert_bin_to_exe.py

# 4. 验证输出
head ../.workspace/workload_mem.exe
head ../.workspace/workload_ins.exe

# 5. 运行 CPU
cd ..
python src/main.py

# 6. 运行测试
pytest tests/test_fetch.py -v
```

## 技术细节

### SRAM 初始化时序

1. **构建阶段**: `build_cpu()` 函数创建 SRAM 实例
2. **初始化时机**: Assassyn 后端在生成仿真器时读取 `init_file`
3. **数据加载**: 仿真器启动时将数据加载到内存数组
4. **访问**: CPU 通过地址总线访问初始化的数据

### 内存访问模式

```python
# 在 src/fetch.py 中访问 icache:
sram_addr = (pc_reg[0]) >> UInt(32)(2)  # PC 除以4得到字地址
icache.build(
    we=Bits(1)(0),      # 写使能=0 (读取)
    re=Bits(1)(1),      # 读使能=1
    addr=sram_addr,     # 地址
    wdata=Bits(32)(0)   # 写数据（读取时忽略）
)
```

### 地址计算

- **字节地址到字地址**: `word_addr = byte_addr >> 2` (除以4)
- **字地址到字节地址**: `byte_addr = word_addr << 2` (乘以4)

例如：
- PC = 0x00000000 → SRAM 地址 = 0 → 第一条指令
- PC = 0x00000004 → SRAM 地址 = 1 → 第二条指令
- PC = 0x00000008 → SRAM 地址 = 2 → 第三条指令

## 进阶使用

### 大型程序加载

对于更大的程序：

```python
# 批量生成指令
instructions = []
for i in range(1024):
    instructions.append(0x00000013)  # NOP

with open('text.bin', 'wb') as f:
    for instr in instructions:
        f.write(struct.pack('<I', instr))
```

### 从 ELF 文件提取

```bash
# 使用 objcopy 提取段
riscv32-unknown-elf-objcopy -O binary --only-section=.text program.elf text.bin
riscv32-unknown-elf-objcopy -O binary --only-section=.data program.elf data.bin
```

### 调试技巧

```python
# 在转换后添加验证
def verify_conversion(bin_file, exe_file):
    import struct
    
    # 读取原始二进制
    with open(bin_file, 'rb') as f:
        bin_data = f.read()
    
    # 读取转换后的十六进制
    with open(exe_file, 'r') as f:
        exe_data = [int(line.strip(), 16) for line in f]
    
    # 比较
    for i in range(len(bin_data) // 4):
        orig = struct.unpack('<I', bin_data[i*4:(i+1)*4])[0]
        conv = exe_data[i]
        assert orig == conv, f"Mismatch at word {i}: {orig:08x} != {conv:08x}"
    
    print(f"✅ Verification passed for {bin_file}")

verify_conversion('data.bin', '../.workspace/workload_mem.exe')
verify_conversion('text.bin', '../.workspace/workload_ins.exe')
```

## 参考资料

### 相关文件
- `src/main.py` - CPU 构建和内存初始化
- `src/fetch.py` - 指令读取（icache 访问）
- `src/memory.py` - 数据访问（main_memory 访问）
- `tests/common.py` - 测试工具和 SRAM 初始化辅助函数

### RISC-V 指令格式
- RV32I 基础指令集
- 32位指令字
- 小端序编码

### Assassyn 文档
- Assassyn HDL 语法
- SRAM 模块使用
- 仿真器配置

## 总结

通过本报告提供的方法，您可以：

1. ✅ 使用 `data.bin` 初始化数据内存（main_memory）
2. ✅ 使用 `text.bin` 初始化指令缓存（icache）
3. ✅ 自动转换二进制文件为 Assassyn SRAM 格式
4. ✅ 验证和调试内存初始化过程
5. ✅ 运行完整的 CPU 仿真

关键文件：
- **输入**: `main_test/data.bin`, `main_test/text.bin`
- **转换工具**: `main_test/convert_bin_to_exe.py`
- **输出**: `.workspace/workload_mem.exe`, `.workspace/workload_ins.exe`
- **使用**: `python src/main.py` 自动加载

---

**报告生成日期**: 2025-12-13  
**CPU 架构**: RV32I 五级流水线  
**HDL**: Assassyn  
**工具版本**: Python 3.10+
