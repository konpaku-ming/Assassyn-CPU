# Assassyn-CPU 除法指令结果错误问题调查报告

## 一、问题描述

根据 `logs/div1to10.log` 日志文件，发现从第二次除法开始，除法操作数 Op1 始终为错误值（0x0 或其他错误值），导致后续所有除法结果都不正确。

### 1.1 问题现象

通过日志分析发现：

1. **第一次除法正常**：
   - 操作：0x375f00 ÷ 1  
   - 输入：Op1=0x375f00, Op2=0x1
   - 结果：0x375f00（正确，使用快速路径）
   - Cycle 11: 除法器完成，结果 0x375f00
   - Cycle 13: 写回寄存器 x10

2. **第二次除法异常**：
   - 操作：0x375f00 ÷ 2（预期结果约为 0x1BAF80）
   - 输入：Op1=0x375f00, Op2=0x2（Cycle 17 启动时正确）
   - Cycle 36: 迭代完成，进入后处理
   - Cycle 37: 除法器报告完成，result=0x375f00（**错误**，应该是 ~0x1BAF80）
   - Cycle 38: SRT-4 除法器结果准备就绪：0x0（**再次变化**）

3. **第三次及后续除法持续错误**：
   - Cycle 42 启动第三次除法：Op1=0x0（**错误**，应该使用前一次的正确结果）
   - 后续所有除法的 Op1 都是 0x0 或错误值

### 1.2 关键发现

通过分析日志输出的时间线：

```
Cycle @8:  启动第一次除法 (0x375f00 / 1)
Cycle @10: 第一次除法完成（快速路径），结果 0x375f00
Cycle @13: 第一次除法结果写回 x10

Cycle @17: 启动第二次除法 (0x375f00 / 2) - 输入正确
Cycle @36: 迭代完成
Cycle @37: 除法器报告 result=0x375f00 - 错误！
Cycle @38: 实际注入结果 0x0 - 更加错误！

Cycle @42: 启动第三次除法，Op1=0x0 - 使用了上一次的错误结果
```

**结论**：问题的根源在于第二次除法的计算结果错误，导致寄存器 x10 被写入了错误的值，后续除法使用这个错误值作为输入，形成连锁反应。

## 二、根本原因分析

### 2.1 SRT-4 除法算法背景

Assassyn-CPU 实现了 SRT-4 基数-4 除法算法：
- 每个时钟周期计算 2 位商
- 商数字取值范围：{-2, -1, 0, 1, 2}
- 使用冗余表示，维护两个累加器：Q（商）和 QM（商-1）
- 约 18 个周期完成 32 位除法

### 2.2 Bug 定位

问题出在 `src/divider.py` 第 483-486 行的商累加器更新逻辑：

```python
with Condition(neg != Bits(1)(0)):
    # 当选择负商数字时
    # 原代码（错误）：
    self.Q[0] = concat(self.QM[0][0:30], Bits(1)(1), q[0:0])
```

### 2.3 Bug 详解

**正确的更新公式**：
```
Q_new = (QM << 2) + (4 - q)
```

对于不同的商数字 q：
| q 值 | 应加的值 | 二进制 | 是否进位 |
|------|---------|--------|---------|
| 0    | 4       | 0b100  | 是（进位到第3位） |
| 1    | 3       | 0b11   | 否 |
| 2    | 2       | 0b10   | 否 |

**原代码的计算**：
```python
concat(self.QM[0][0:30], Bits(1)(1), q[0:0])
```
等价于：`QM[0:30] ++ '1' ++ q[0]`

实际结果：
| q 值 | q[0:0] | 结果底2位 | 计算值 | 期望值 |
|------|--------|----------|--------|--------|
| 0 (0b00) | 0 | 0b10 | 2 | 0 + 进位 ❌ |
| 1 (0b01) | 1 | 0b11 | 3 | 3 ✓ |
| 2 (0b10) | 0 | 0b10 | 2 | 2 ✓ |

**核心问题**：当 q=0 时，原代码将底部 2 位设置为 0b10（值为 2），但正确的应该是 0b00（值为 0）并且需要向高位进位 1。

### 2.4 影响范围

这个 bug 影响所有需要选择负商数字的除法操作，特别是：
1. 被除数和除数数值差异较大时
2. 部分余数为负，需要通过加除数来调整时
3. SRT-4 商选择逻辑决定使用 q=-2, -1 或 0 时

对于测试用例 div1to10.exe：
- 第一次除法（÷1）：快速路径，不经过 SRT-4 迭代，正确
- 第二次除法（÷2）：正常 SRT-4 路径，触发 bug，结果错误
- 后续除法：使用错误的操作数，持续错误

## 三、修复方案

### 3.1 代码修改

修改 `src/divider.py` 第 483-503 行：

```python
with Condition(neg != Bits(1)(0)):
    # Negative quotient: Q = (QM << 2) + (4 - q)
    # 需要正确处理 q=0 时的进位
    with Condition(q == Bits(2)(0)):
        # q=0: 加 4 产生进位
        # 底部 2 位 = 0，QM 需要 +1
        qm_plus_carry = (self.QM[0].bitcast(UInt(33)) + Bits(33)(1)).bitcast(Bits(33))
        self.Q[0] = concat(qm_plus_carry[0:30], Bits(2)(0b00))
    with Condition(q != Bits(2)(0)):
        # q=1 或 q=2: 无进位
        # 使用 (~q + 1) 计算 (4-q)
        #   q=1: ~0b01 + 1 = 0b10 + 1 = 0b11 = 3 ✓
        #   q=2: ~0b10 + 1 = 0b01 + 1 = 0b10 = 2 ✓
        q_inverted_plus_1 = ((~q).bitcast(UInt(2)) + Bits(2)(1)).bitcast(Bits(2))
        self.Q[0] = concat(self.QM[0][0:30], q_inverted_plus_1)
```

### 3.2 调试增强

为了便于未来调试，在 DIV_END 状态添加了详细日志：

```python
log("Divider: DIV_END - Q=0x{:x}, QM=0x{:x}, shift_rem[32:64]=0x{:x}",
    self.Q[0], self.QM[0], self.shift_rem[0][32:64])

# ... 余数调整逻辑 ...

log("Divider: div_sign=0x{:x}, q_needs_neg={}, fin_q[0:31]=0x{:x}",
    self.div_sign[0], q_needs_neg, self.fin_q[0][0:31])

log("Divider: q_signed=0x{:x}, rem_signed=0x{:x}, is_rem={}", 
    q_signed, rem_signed, self.is_rem[0])
```

### 3.3 验证方法

建议的验证步骤：
1. 重新运行 div1to10.exe 测试，生成新的日志
2. 检查第二次除法（0x375f00 ÷ 2）的结果是否为 0x1BAF80
3. 检查后续除法的 Op1 是否为正确的累积结果
4. 验证所有除法结果：1! ÷ 1 = 1, 1! ÷ 2 = 0, ..., 10! ÷ 10 = 362880

## 四、技术细节说明

### 4.1 SRT-4 算法的冗余表示

SRT-4 使用冗余数字系统，允许商数字为负值。维护两个寄存器：
- **Q**：当前商的累加值
- **QM**：Q - 1 的值

当选择负商数字时，使用 QM 而不是 Q 进行下一次迭代，这样可以避免借位传播，简化硬件实现。

### 4.2 商数字为 0 的特殊性

当商数字 q=0 且为负数表示时：
- 实际含义：部分余数接近 0，不需要减除数
- 更新公式：Q = QM * 4 + 4
- 这相当于 Q = (QM + 1) * 4
- 需要先对 QM 加 1（进位），然后左移 2 位

原代码忽略了这个进位，导致：
- Q = QM * 4 + 2（错误）
- 而不是 Q = QM * 4 + 4（正确）

### 4.3 为什么第一次除法正确

除数为 1 时，除法器使用快速路径（DIV_1 状态）：
```python
with Condition(div_by_one):
    self.state[0] = self.DIV_1
    # 快速路径：商 = 被除数，余数 = 0
    self.result[0] = self.is_rem[0].select(
        Bits(32)(0),         # 余数 = 0
        self.dividend_in[0]  # 商 = 被除数
    )
```

这个路径跳过了 SRT-4 迭代，因此不会触发商累加 bug。

## 五、总结

### 5.1 问题根源

Assassyn-CPU 的 SRT-4 除法器在处理负商数字时，商累加器更新逻辑存在进位处理错误。当选择的负商数字为 0 时，未能正确处理从底部 2 位到第 3 位的进位，导致商的计算结果错误。

### 5.2 修复效果

修复后的代码：
- 正确处理 q=0 时的进位：QM + 1 后左移
- 正确处理 q=1, 2 时的无进位情况：使用 (~q + 1) 计算
- 保证商累加器在所有情况下都能正确更新

### 5.3 经验教训

1. **位操作的精确性**：在硬件算法实现中，位操作必须精确到每一位，进位处理尤其关键
2. **边界条件测试**：商数字 q=0 是一个边界条件，容易被忽略
3. **调试日志的重要性**：详细的日志输出帮助快速定位问题
4. **算法验证**：应该对 SRT-4 的所有商数字选择情况（q=-2,-1,0,1,2，neg=0/1）进行单元测试

---

**报告人**：GitHub Copilot  
**日期**：2025-12-27  
**版本**：v1.0
