# Assassyn CPU 除法指令问题分析报告

## 问题概述

在single_div测试程序中，除法指令执行后目标寄存器未能获得正确的结果。该程序计算10的阶乘（3,628,800）除以2，期望结果为1,814,400（0x1BAF80），但实际结果为0。

## 测试程序分析

### 程序代码
```assembly
lui  a0, 886         ; 初始化 a0 = 0x376000
addi a0, a0, -256    ; a0 = 0x376000 + 0xFFFFFF00 = 0x375F00 (3,628,800)
li   a1, 2           ; a1 = 2
div  a0, a0, a1      ; a0 = a0 / 2 = 0x375F00 / 2
ebreak               ; 暂停
```

### 期望结果
- 被除数：0x375F00 = 3,628,800 (10!)
- 除数：0x2 = 2
- 商：0x1BAF80 = 1,814,400
- 余数：0x0 = 0

## 日志分析

通过检查logs/single_div.log，发现以下关键信息：

### 除法开始（第7周期）
```
Cycle @7.00: [Executor] Divider: Start division, dividend=0x375f00, divisor=0x2, signed=1
Cycle @7.00: [Executor] EX: Starting ~18-cycle division (SRT-4)
Cycle @7.00: [Executor] EX: Saved pending DIV rd=x10
```
除法器正确启动，被除数和除数的值都正确。

### 除法完成（第27周期）
```
Cycle @27.00: [Executor] Divider: DIV_END - Q=0x0, QM=0x1ffffffff, shift_rem[32:64]=0xdd7c0
Cycle @27.00: [Executor] Divider: Remainder was positive, fin_q=0x0
Cycle @27.00: [Executor] Divider: Completed, result=0x0
```
除法器完成计算，但商累加器Q为0x0，这是错误的。

### 结果写回（第28周期）
```
Cycle @28.00: [Executor] EX: Injecting pending DIV result to MEM (rd=x10, result=0x0)
```
错误的结果0被写入寄存器x10（a0）。

## 根本原因

通过深入对比SRT4目录下的Verilog参考实现与Python Assassyn实现，发现了**四个关键的位操作错误**，这些错误共同导致除法计算完全失败。

### Bug 1: Q/QM累加器位切片错误

**位置：** `divider.py` 第482、492、502、510、513行

**问题描述：**  
商累加器Q和QM的更新使用了错误的位切片范围。

**Verilog参考（SRT4.v:186）：**
```verilog
Q <= {Q[WID-3:0],q};  // 对于WID=32, 即Q[29:0]
```

其中`WID-3 = 32-3 = 29`，所以是`Q[29:0]`，代表30位（bits 29到0）。

**Python错误代码：**
```python
self.Q[0] = concat(self.Q[0][0:30], q)  # 31位 + 2位 = 33位
```

使用`[0:30]`提取了31位（bits 0到30），而非30位。

**为什么错误：**  
在33位的Q寄存器中：
- 正确做法：取Q[0:29]（30位）+ 新q（2位）= 32位，更新Q的低32位
- 错误做法：取Q[0:30]（31位）+ 新q（2位）= 33位，覆盖全部Q

错误导致每次迭代时前一次的商数字被过度左移，最终累积的商值严重错误。

### Bug 2: Q/QM寄存器触发器逻辑缺失

**位置：** `divider.py` 原第392-393行（DIV_PRE状态）

**问题描述：**  
Python实现只在DIV_PRE状态显式初始化Q和QM，缺少Verilog中`else`分支的清零逻辑。

**Verilog参考（SRT4.v:179-202）：**
```verilog
always @(posedge clk) begin
    if(rst)begin
        Q <= 'b0;
        QM<= 'b0;
    end
    else if(state==DIV_WORKING)begin
        // Update Q and QM during iterations
    end
    else begin
        Q <= 'b0;  // 关键：在非DIV_WORKING状态清零
        QM<= 'b0;
    end
end
```

Verilog的`else`分支确保Q和QM在所有非DIV_WORKING状态（IDLE、DIV_PRE、DIV_END等）时都被清零。

**问题影响：**  
多次连续除法操作时，Q和QM可能保留上一次运算的值，导致状态污染。

**修复：**  
添加统一的条件清零逻辑：
```python
with Condition(self.state[0] != self.DIV_WORKING):
    self.Q[0] = Bits(33)(0)
    self.QM[0] = Bits(33)(0)
```

### Bug 3: shift_rem部分余数位切片错误

**位置：** `divider.py` DIV_WORKING状态中8处shift_rem访问

**问题描述：**  
在DIV_WORKING状态更新部分余数时，使用了错误的位范围提取shift_rem的高33位。

**Verilog参考（SRT4.v:169）：**
```verilog
shift_rem <= {shift_rem[62:30] + value, shift_rem[29:0], 2'b0};
```

For WID=32:
- `shift_rem[62:30]` = Verilog从位62到位30 = 33位
- Python等效：`shift_rem[30:62]` = 从位30到位62 = 33位

**Python错误代码：**
```python
self.shift_rem[0] = concat(self.shift_rem[0][32:64], ...)  # 错误！偏移2位
```

使用了`[32:64]`而非`[30:62]`，导致每次迭代提取错误的33位进行运算。

**问题影响：**  
- 部分余数的高位提取错误
- 每次迭代计算的余数更新错误
- 即使Q/QM累加正确，除法结果也会错误

**修复：**  
将所有8处`shift_rem[0][32:64]`改为`shift_rem[0][30:62]`。

### Bug 4: shift_divisor零扩展错误

**位置：** `divider.py` DIV_WORKING和DIV_END状态

**问题描述：**  
shift_divisor的构造方式错误，导致值被意外放大2倍。

**Verilog参考（SRT4.v:109, 108）：**
```verilog
wire[WID:0] shift_divisor;  // 33位
assign shift_divisor = divisor_r<<div_shift;  // 32位结果零扩展到33位
assign qds_table = shift_divisor[WID-1:WID-4];  // [31:28]
```

在Verilog中，32位表达式赋给33位wire时会自动零扩展：
```
shift_divisor = {1'b0, divisor_r<<div_shift}
```

For WID=32，qds_table提取`shift_divisor[31:28]`（top 4 bits of the 32-bit shifted result）。

**Python错误代码：**
```python
shift_divisor = concat(divisor_shifted, Bits(1)(0))  # 左移1位！
d_high = shift_divisor[29:32]  # 错误位置
```

`concat(divisor_shifted, Bits(1)(0))`创建`{divisor_shifted[31:0], 1'b0}`，相当于将divisor_shifted**左移1位**，而非零扩展！

**问题影响：**  
- shift_divisor值错误（放大2倍）
- d_high提取位置错误
- 商选择逻辑（q_sel）的输入错误
- 每次迭代选择的商数字可能完全错误
- 余数调整时使用的除数值也错误

**修复：**
1. 修改concat顺序：`concat(Bits(1)(0), divisor_shifted)` 实现零扩展
2. 修改d_high提取：`shift_divisor[28:31]`（对应Verilog [31:28]）


## 修复方案

共修复了**四个关键的位操作错误**：

### 修复1：Q/QM累加器位切片错误（commit 8116a6a）

将所有商累加器Q和QM更新中的位切片从`[0:30]`改为`[0:29]`：

#### 修复的代码行

1. **第478行：** Q累加器正向更新（正商数字）
   ```python
   self.Q[0] = concat(self.Q[0][0:29], q)  # 修改：30位 + 2位
   ```

2. **第488行：** Q累加器负向更新（q=0的情况）
   ```python
   self.Q[0] = concat(qm_plus_one[0:29], Bits(2)(0b00))
   ```

3. **第498行：** Q累加器负向更新（q≠0的情况）
   ```python
   self.Q[0] = concat(self.QM[0][0:29], four_minus_q)
   ```

4. **第506行：** QM累加器更新（正向且非零）
   ```python
   self.QM[0] = concat(self.Q[0][0:29], q_minus_1)
   ```

5. **第509行：** QM累加器更新（负向或零）
   ```python
   self.QM[0] = concat(self.QM[0][0:29], ~q)
   ```

### 修复2：Q/QM寄存器触发器逻辑（commit cf592c0）

#### 修复内容
1. 移除DIV_PRE状态中的显式Q/QM初始化（原第392-393行）
2. 添加统一的条件清零逻辑：

```python
# Clear Q and QM when not in DIV_WORKING state (matches Verilog behavior)
# This ensures Q and QM are reset between divisions
with Condition(self.state[0] != self.DIV_WORKING):
    self.Q[0] = Bits(33)(0)
    self.QM[0] = Bits(33)(0)
```

这确保了：
- **IDLE/ERROR/DIV_1状态**：Q=0, QM=0
- **DIV_PRE状态**：Q=0, QM=0（准备开始新的除法）
- **DIV_WORKING状态**：Q和QM正常更新累积商
- **DIV_END状态**：Q=0, QM=0（完成后清零）
- **多次除法之间**：寄存器自动复位，无状态污染

### 修复3：shift_rem部分余数位切片（commit 7ab30b7）

将DIV_WORKING状态中所有8处部分余数访问从`[32:64]`改为`[30:62]`：

```python
# 修复前（错误）
self.shift_rem[0] = concat(self.shift_rem[0][32:64], self.shift_rem[0][0:29], Bits(2)(0))
new_rem_high = self.shift_rem[0][32:64].bitcast(UInt(33)) + ...

# 修复后（正确）
self.shift_rem[0] = concat(self.shift_rem[0][30:62], self.shift_rem[0][0:29], Bits(2)(0))
new_rem_high = self.shift_rem[0][30:62].bitcast(UInt(33)) + ...
```

涉及修改：
- 6处shift_rem更新操作
- 6处用于加减运算的余数高位提取

### 修复4：shift_divisor零扩展（commit d4b6eac）

修改DIV_WORKING和DIV_END状态中shift_divisor的构造和d_high的提取：

```python
# 修复前（错误 - 左移1位）
shift_divisor = concat(divisor_shifted, Bits(1)(0))  # {divisor[31:0], 1'b0}
d_high = shift_divisor[29:32]

# 修复后（正确 - 零扩展）
shift_divisor = concat(Bits(1)(0), divisor_shifted)  # {1'b0, divisor[31:0]}
d_high = shift_divisor[28:31]  # 对应Verilog [31:28]
```

涉及修改：
- DIV_WORKING状态：shift_divisor构造和d_high提取
- DIV_END状态：shift_divisor构造（用于余数调整）

## 预期效果

修复全部四个bug后，除法器应该能够：
1. 正确累积商数字到Q寄存器（修复1）
2. 正确维护寄存器状态，避免多次除法间污染（修复2）
3. 正确更新部分余数（修复3）
4. 正确计算商选择逻辑的输入（修复4）
5. 在16次迭代后得到正确的32位商
6. single_div测试中，寄存器x10（a0）应该得到0x1BAF80（1,814,400）

## 结论

### 问题定位
发现并修复了**四个关键的位操作错误**：

1. **商累加器位切片错误** ✅已修复（commit 8116a6a）
   - 问题：使用31位`[0:30]`而非30位`[0:29]`进行移位操作
   - 影响：每次迭代时商数字累积错误
   - 修复：修改5处位切片

2. **Q/QM寄存器触发器逻辑缺失** ✅已修复（commit cf592c0）
   - 问题：缺少非DIV_WORKING状态的清零逻辑
   - 影响：多次除法操作时可能产生状态污染
   - 修复：添加条件复位逻辑

3. **shift_rem部分余数位切片错误** ✅已修复（commit 7ab30b7）
   - 问题：使用`[32:64]`而非`[30:62]`提取余数高位
   - 影响：每次迭代余数更新错误
   - 修复：修改8处位切片

4. **shift_divisor零扩展错误** ✅已修复（commit d4b6eac）
   - 问题：concat顺序错误导致左移1位而非零扩展
   - 影响：除数值放大2倍，商选择逻辑输入错误
   - 修复：修正concat顺序和d_high提取位置

### 是计算错误还是写回错误？
这是**计算错误**，具体包含四个方面的位操作错误：
1. **商累积错误**：Q/QM位切片导致商数字未被正确累积
2. **状态管理错误**：寄存器未正确复位
3. **余数计算错误**：shift_rem位切片导致余数更新错误  
4. **除数归一化错误**：shift_divisor零扩展错误导致商选择错误

这四个错误相互独立但共同作用，任何一个错误都会导致除法完全失败。写回路径本身没有问题，只是写回了错误的计算结果。

### 错误原因总结
所有错误都源于**Verilog到Python的位操作转换错误**：
- Verilog使用`[high:low]`降序表示法
- Python使用`[low:high]`升序表示法
- concat参数顺序对应关系理解错误
- 零扩展与左移操作混淆

### 修复验证
建议在修复后运行以下测试以验证：
1. single_div测试程序 - 验证基本除法（10! / 2 = 1,814,400）
2. div1to10测试程序 - 验证多个连续除法操作
3. 其他包含DIV/REM/DIVU/REMU指令的测试

---

**报告生成时间：** 2025-12-27  
**修复提交：** 
- commit 8116a6a (Q/QM位切片修复)
- commit cf592c0 (触发器逻辑修复)
- commit 7ab30b7 (shift_rem位切片修复)
- commit d4b6eac (shift_divisor零扩展修复)
