# Assassyn CPU 除法指令问题分析报告

## 问题概述

在single_div测试程序中，除法指令执行后目标寄存器未能获得正确的结果。该程序计算10的阶乘（3,628,800）除以2，期望结果为1,814,400（0x1BAF80），但实际结果为0。

## 测试程序分析

### 程序代码
```assembly
lui  a0, 886         ; 初始化 a0 = 0x376000
addi a0, a0, -256    ; a0 = 0x376000 + 0xFFFFFF00 = 0x375F00 (3,628,800)
li   a1, 2           ; a1 = 2
div  a0, a0, a1      ; a0 = a0 / 2 = 0x375F00 / 2
ebreak               ; 暂停
```

### 期望结果
- 被除数：0x375F00 = 3,628,800 (10!)
- 除数：0x2 = 2
- 商：0x1BAF80 = 1,814,400
- 余数：0x0 = 0

## 日志分析

通过检查logs/single_div.log，发现以下关键信息：

### 除法开始（第7周期）
```
Cycle @7.00: [Executor] Divider: Start division, dividend=0x375f00, divisor=0x2, signed=1
Cycle @7.00: [Executor] EX: Starting ~18-cycle division (SRT-4)
Cycle @7.00: [Executor] EX: Saved pending DIV rd=x10
```
除法器正确启动，被除数和除数的值都正确。

### 除法完成（第27周期）
```
Cycle @27.00: [Executor] Divider: DIV_END - Q=0x0, QM=0x1ffffffff, shift_rem[32:64]=0xdd7c0
Cycle @27.00: [Executor] Divider: Remainder was positive, fin_q=0x0
Cycle @27.00: [Executor] Divider: Completed, result=0x0
```
除法器完成计算，但商累加器Q为0x0，这是错误的。

### 结果写回（第28周期）
```
Cycle @28.00: [Executor] EX: Injecting pending DIV result to MEM (rd=x10, result=0x0)
```
错误的结果0被写入寄存器x10（a0）。

## 根本原因

问题出在`src/divider.py`文件中商累加器Q和QM的更新逻辑。

### SRT-4除法算法简介
SRT-4是一种基数-4（radix-4）的除法算法，每个时钟周期计算2位商。对于32位除法，需要16次迭代（32 ÷ 2 = 16）。

在每次迭代中：
1. 根据部分余数和除数选择商数字q ∈ {-2, -1, 0, 1, 2}
2. 更新部分余数
3. 更新商累加器Q和QM（Q-1）

商累加器Q应该在每次迭代时：
- 左移2位（为新的商数字腾出空间）
- 在最低2位插入新的商数字

### 位切片错误
在Python实现的第482、492、502、510、513行，代码使用了错误的位切片范围：

**错误代码：**
```python
# 第482行
self.Q[0] = concat(self.Q[0][0:30], q)
```

这里`Q[0:30]`提取了31位（位0到位30，包含两端），但参考的Verilog实现中使用的是`Q[29:0]`，即30位。

**Verilog参考代码（SRT4/SRT4.v第186行）：**
```verilog
if(~neg)begin
    Q <= {Q[WID-3:0],q};  // 对于WID=32, 即Q[29:0]
end
```
其中`WID-3 = 32-3 = 29`，所以是`Q[29:0]`，代表30位。

### 为什么31位是错误的？

在33位的Q寄存器中（Q[32:0]）：
- 正确做法：取Q[0:29]（30位）+ 新q（2位）= 32位，赋给Q[31:0]，Q[32]保持不变
- 错误做法：取Q[0:30]（31位）+ 新q（2位）= 33位，赋给Q[32:0]

错误做法会导致：
- 每次迭代时，前一次的商数字被过多地左移
- 最终累积的商值严重错误
- 在simple_div的情况下，最终Q=0

## 修复方案

将所有商累加器Q和QM更新中的位切片从`[0:30]`改为`[0:29]`：

### 修复的代码行

1. **第482行：** Q累加器正向更新（正商数字）
   ```python
   self.Q[0] = concat(self.Q[0][0:29], q)  # 修改：30位 + 2位
   ```

2. **第492行：** Q累加器负向更新（q=0的情况）
   ```python
   self.Q[0] = concat(qm_plus_one[0:29], Bits(2)(0b00))
   ```

3. **第502行：** Q累加器负向更新（q≠0的情况）
   ```python
   self.Q[0] = concat(self.QM[0][0:29], four_minus_q)
   ```

4. **第510行：** QM累加器更新（正向且非零）
   ```python
   self.QM[0] = concat(self.Q[0][0:29], q_minus_1)
   ```

5. **第513行：** QM累加器更新（负向或为零）
   ```python
   self.QM[0] = concat(self.QM[0][0:29], ~q)
   ```

## 预期效果

修复后，除法器应该能够：
1. 正确累积商数字到Q寄存器
2. 在16次迭代后得到正确的32位商
3. single_div测试中，寄存器x10（a0）应该得到0x1BAF80（1,814,400）

## 结论

### 问题定位
- ✅ 除法**计算逻辑**是正确的（SRT-4算法本身没有问题）
- ✅ 结果**写回寄存器**的路径是正确的
- ❌ 问题在于**商累加器更新**时的位切片范围错误

### 是计算错误还是写回错误？
这是一个**计算错误**，具体来说是商累加过程中的位操作错误。除法器虽然完成了全部16次迭代，但由于每次更新Q时使用了错误的位宽，导致商数字没有被正确累积。写回路径本身没有问题，只是写回了错误的计算结果。

### 修复验证
建议在修复后运行以下测试以验证：
1. single_div测试程序 - 验证基本除法
2. div1to10测试程序 - 验证多个除法操作
3. 其他包含DIV/REM/DIVU/REMU指令的测试

---

**报告生成时间：** 2025-12-27  
**修复提交：** commit 8116a6a
