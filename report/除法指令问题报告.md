# Assassyn CPU 除法指令问题分析报告

## 问题概述

在single_div测试程序中，除法指令执行后目标寄存器未能获得正确的结果。该程序计算10的阶乘（3,628,800）除以2，期望结果为1,814,400（0x1BAF80），但实际结果为0。

## 测试程序分析

### 程序代码
```assembly
lui  a0, 886         ; 初始化 a0 = 0x376000
addi a0, a0, -256    ; a0 = 0x376000 + 0xFFFFFF00 = 0x375F00 (3,628,800)
li   a1, 2           ; a1 = 2
div  a0, a0, a1      ; a0 = a0 / 2 = 0x375F00 / 2
ebreak               ; 暂停
```

### 期望结果
- 被除数：0x375F00 = 3,628,800 (10!)
- 除数：0x2 = 2
- 商：0x1BAF80 = 1,814,400
- 余数：0x0 = 0

## 日志分析

通过检查logs/single_div.log，发现以下关键信息：

### 除法开始（第7周期）
```
Cycle @7.00: [Executor] Divider: Start division, dividend=0x375f00, divisor=0x2, signed=1
Cycle @7.00: [Executor] EX: Starting ~18-cycle division (SRT-4)
Cycle @7.00: [Executor] EX: Saved pending DIV rd=x10
```
除法器正确启动，被除数和除数的值都正确。

### 除法完成（第27周期）
```
Cycle @27.00: [Executor] Divider: DIV_END - Q=0x0, QM=0x1ffffffff, shift_rem[32:64]=0xdd7c0
Cycle @27.00: [Executor] Divider: Remainder was positive, fin_q=0x0
Cycle @27.00: [Executor] Divider: Completed, result=0x0
```
除法器完成计算，但商累加器Q为0x0，这是错误的。

### 结果写回（第28周期）
```
Cycle @28.00: [Executor] EX: Injecting pending DIV result to MEM (rd=x10, result=0x0)
```
错误的结果0被写入寄存器x10（a0）。

## 根本原因

问题出在`src/divider.py`文件中商累加器Q和QM的更新逻辑。

### SRT-4除法算法简介
SRT-4是一种基数-4（radix-4）的除法算法，每个时钟周期计算2位商。对于32位除法，需要16次迭代（32 ÷ 2 = 16）。

在每次迭代中：
1. 根据部分余数和除数选择商数字q ∈ {-2, -1, 0, 1, 2}
2. 更新部分余数
3. 更新商累加器Q和QM（Q-1）

商累加器Q应该在每次迭代时：
- 左移2位（为新的商数字腾出空间）
- 在最低2位插入新的商数字

### 位切片错误
在Python实现的第482、492、502、510、513行，代码使用了错误的位切片范围：

**错误代码：**
```python
# 第482行
self.Q[0] = concat(self.Q[0][0:30], q)
```

这里`Q[0:30]`提取了31位（位0到位30，包含两端），但参考的Verilog实现中使用的是`Q[29:0]`，即30位。

**Verilog参考代码（SRT4/SRT4.v第186行）：**
```verilog
if(~neg)begin
    Q <= {Q[WID-3:0],q};  // 对于WID=32, 即Q[29:0]
end
```
其中`WID-3 = 32-3 = 29`，所以是`Q[29:0]`，代表30位。

### 为什么31位是错误的？

在33位的Q寄存器中（Q[32:0]）：
- 正确做法：取Q[0:29]（30位）+ 新q（2位）= 32位，赋给Q[31:0]，Q[32]保持不变
- 错误做法：取Q[0:30]（31位）+ 新q（2位）= 33位，赋给Q[32:0]

错误做法会导致：
- 每次迭代时，前一次的商数字被过多地左移
- 最终累积的商值严重错误
- 在simple_div的情况下，最终Q=0

## 修复方案

共修复了两个关键问题：

### 修复1：位切片错误（commit 8116a6a）

将所有商累加器Q和QM更新中的位切片从`[0:30]`改为`[0:29]`：

#### 修复的代码行

1. **第482行：** Q累加器正向更新（正商数字）
   ```python
   self.Q[0] = concat(self.Q[0][0:29], q)  # 修改：30位 + 2位
   ```

2. **第492行：** Q累加器负向更新（q=0的情况）
   ```python
   self.Q[0] = concat(qm_plus_one[0:29], Bits(2)(0b00))
   ```

3. **第502行：** Q累加器负向更新（q≠0的情况）
   ```python
   self.Q[0] = concat(self.QM[0][0:29], four_minus_q)
   ```

4. **第510行：** QM累加器更新（正向且非零）
   ```python
   self.QM[0] = concat(self.Q[0][0:29], q_minus_1)
   ```

5. **第513行：** QM累加器更新（负向或为零）
   ```python
   self.QM[0] = concat(self.QM[0][0:29], ~q)
   ```

### 修复2：Q/QM寄存器触发器逻辑（commit cf592c0）

通过对比Verilog参考实现，发现Python代码缺少Q和QM寄存器的复位逻辑。

#### Verilog实现（SRT4.v:179-202）
```verilog
always @(posedge clk) begin
    if(rst)begin
        Q <= 'b0;
        QM<= 'b0;
    end
    else if(state==DIV_WORKING)begin
        // Update Q and QM during iterations
    end
    else begin
        Q <= 'b0;  // 关键：在非DIV_WORKING状态清零
        QM<= 'b0;
    end
end
```

Verilog的else分支确保Q和QM在非DIV_WORKING状态（包括IDLE、DIV_PRE、DIV_END等）时都被清零。这对于正确的触发器行为和多次连续除法操作至关重要。

#### Python原有问题
- 只在DIV_PRE状态显式初始化Q和QM一次
- 缺少对其他状态的清零逻辑
- 可能导致多次除法操作时状态污染

#### 修复内容
1. 移除DIV_PRE状态中的显式Q/QM初始化（原第392-393行）
2. 添加统一的条件清零逻辑：

```python
# Clear Q and QM when not in DIV_WORKING state (matches Verilog behavior)
# This ensures Q and QM are reset between divisions
with Condition(self.state[0] != self.DIV_WORKING):
    self.Q[0] = Bits(33)(0)
    self.QM[0] = Bits(33)(0)
```

这确保了：
- **IDLE/ERROR/DIV_1状态**：Q=0, QM=0
- **DIV_PRE状态**：Q=0, QM=0（准备开始新的除法）
- **DIV_WORKING状态**：Q和QM正常更新累积商
- **DIV_END状态**：Q=0, QM=0（完成后清零）
- **多次除法之间**：寄存器自动复位，无状态污染

## 预期效果

修复后，除法器应该能够：
1. 正确累积商数字到Q寄存器
2. 在16次迭代后得到正确的32位商
3. single_div测试中，寄存器x10（a0）应该得到0x1BAF80（1,814,400）

## 结论

### 问题定位
发现并修复了两个关键问题：

1. **商累加器位切片错误** ✅已修复
   - 问题：使用31位而非30位进行移位操作
   - 影响：每次迭代时商数字累积错误
   - 修复：将所有`[0:30]`改为`[0:29]`

2. **Q/QM寄存器触发器逻辑缺失** ✅已修复
   - 问题：缺少非DIV_WORKING状态的清零逻辑
   - 影响：多次除法操作时可能产生状态污染
   - 修复：添加条件复位逻辑确保正确的触发器行为

### 是计算错误还是写回错误？
这是**计算错误**，具体包含两个方面：
1. **商累积错误**：位操作错误导致商数字未被正确累积
2. **状态管理错误**：寄存器未正确复位可能导致连续除法操作失败

写回路径本身没有问题，只是写回了错误的计算结果。

### 修复验证
建议在修复后运行以下测试以验证：
1. single_div测试程序 - 验证基本除法（10! / 2）
2. div1to10测试程序 - 验证多个连续除法操作
3. 其他包含DIV/REM/DIVU/REMU指令的测试

---

**报告生成时间：** 2025-12-27  
**修复提交：** 
- commit 8116a6a (位切片修复)
- commit cf592c0 (触发器逻辑修复)
