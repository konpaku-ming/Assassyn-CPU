# Assassyn-CPU 数据前递（Bypass）性能分析报告

## 1. 报告概述

本报告对比分析了 Assassyn-CPU 在启用数据前递（Bypass）机制的情况下与不启用 Bypass（三条指令之内有依赖就 Stall）之间的性能差异。通过分析三个工作负载（0to100、multiply、vvadd）的运行日志，评估 Bypass 对 CPU 性能的提升效果。

**性能指标**: 程序运行的总周期数（越少越好）

---

## 2. 测试环境

### 2.1 CPU 配置
- **架构**: Assassyn-CPU 五级流水线（IF-ID-EX-MEM-WB）
- **数据前递机制**: 
  - EX-MEM Bypass：EX 阶段可以直接使用 MEM 阶段的结果
  - MEM-WB Bypass：EX 阶段可以直接使用 WB 阶段的结果
  - WB Bypass：EX 阶段可以直接使用即将写回的结果
- **流水线停顿策略**（无 Bypass）：
  - 三条指令之内有依赖关系时，流水线必须停顿（Stall）
  - 停顿时间取决于依赖距离

### 2.2 测试工作负载
1. **0to100**: 简单循环计数程序（从 0 计数到 100）
2. **multiply**: 矩阵乘法运算程序
3. **vvadd**: 向量加法运算程序

---

## 3. 性能测试结果

### 3.1 总体性能对比

| 工作负载 | 有 Bypass 周期数 | 无 Bypass 周期数 | 性能提升 | 提升百分比 |
|---------|-----------------|-----------------|---------|----------|
| 0to100  | **412**         | 616             | 204     | **33.12%** |
| multiply| **4,640**       | 7,756           | 3,116   | **40.18%** |
| vvadd   | **8,433**       | 15,949          | 7,516   | **47.13%** |

**关键发现**:
- 使用 Bypass 后，所有三个工作负载的性能均得到**显著提升**
- 性能提升范围从 **33%** 到 **47%**，平均约为 **40%**
- Bypass 机制在数据依赖密集的程序中效果更明显（如 vvadd）

### 3.2 详细性能指标

#### 3.2.1 0to100 工作负载

| 指标                         | 数值     |
|-----------------------------|---------|
| 总执行周期数（有 Bypass）      | 412     |
| EX-MEM Bypass 使用次数       | 2       |
| MEM-WB Bypass 使用次数       | 200     |
| WB Bypass 使用次数           | 301     |
| 总 Bypass 使用次数           | 503     |
| 无 Bypass 总停顿周期数        | 204     |
| 理论周期数（无 Bypass）        | 616     |
| 性能提升周期数               | 204     |
| 性能提升百分比               | 33.12%  |

**分析**:
- 0to100 是简单的循环计数程序，包含大量数据依赖
- Bypass 机制避免了 204 个周期的停顿，性能提升 33.12%
- MEM-WB Bypass 和 WB Bypass 使用频繁（共 501 次），说明程序中大多数依赖距离为 2-3 条指令

#### 3.2.2 multiply 工作负载

| 指标                         | 数值      |
|-----------------------------|----------|
| 总执行周期数（有 Bypass）      | 4,640    |
| EX-MEM Bypass 使用次数       | 1,005    |
| MEM-WB Bypass 使用次数       | 1,106    |
| WB Bypass 使用次数           | 1,311    |
| 总 Bypass 使用次数           | 3,422    |
| 无 Bypass 总停顿周期数        | 3,116    |
| 理论周期数（无 Bypass）        | 7,756    |
| 性能提升周期数               | 3,116    |
| 性能提升百分比               | 40.18%   |

**分析**:
- multiply 是计算密集型程序，包含大量矩阵乘法运算
- 总共使用了 3,422 次 Bypass，避免了 3,116 个周期的停顿
- 性能提升 40.18%，说明矩阵乘法中存在密集的数据依赖
- EX-MEM Bypass 使用 1,005 次，说明存在大量紧密相邻的依赖关系（1 条指令距离）

#### 3.2.3 vvadd 工作负载

| 指标                         | 数值      |
|-----------------------------|----------|
| 总执行周期数（有 Bypass）      | 8,433    |
| EX-MEM Bypass 使用次数       | 2,706    |
| MEM-WB Bypass 使用次数       | 2,104    |
| WB Bypass 使用次数           | 2,706    |
| 总 Bypass 使用次数           | 7,516    |
| 无 Bypass 总停顿周期数        | 7,516    |
| 理论周期数（无 Bypass）        | 15,949   |
| 性能提升周期数               | 7,516    |
| 性能提升百分比               | 47.13%   |

**分析**:
- vvadd 是向量加法程序，包含大量向量元素的加法运算
- 这是性能提升最显著的工作负载，达到 **47.13%**
- 总共使用了 7,516 次 Bypass，避免了 7,516 个周期的停顿
- EX-MEM Bypass 和 WB Bypass 各使用 2,706 次，说明存在大量距离为 1 和 3 的依赖关系
- 向量操作的特点导致了非常密集的数据依赖模式

---

## 4. Bypass 机制分析

### 4.1 Bypass 架构特点

当前实现的 Bypass 机制具有以下特点：
- **EX-MEM Bypass**: 允许 EX 阶段直接获取 MEM 阶段的计算结果
  - 避免停顿周期数：2 个周期
  - 适用于相邻指令的依赖关系
- **MEM-WB Bypass**: 允许 EX 阶段直接获取 WB 阶段的结果
  - 避免停顿周期数：1 个周期
  - 适用于距离 2 条指令的依赖关系
- **WB Bypass**: 允许 EX 阶段直接获取即将写回寄存器的结果
  - 避免停顿周期数：0 个周期（理论上）
  - 适用于距离 3 条指令的依赖关系

### 4.2 Bypass 效能评估

#### 优势：
1. **显著的性能提升**: 所有工作负载的性能提升都在 33% 以上，平均约 40%
2. **消除大量停顿**: Bypass 机制避免了数千个周期的流水线停顿
3. **适应不同依赖模式**: 三种 Bypass 机制可以处理不同距离的数据依赖
4. **硬件开销合理**: 相比性能提升，Bypass 的硬件实现成本是合理的

#### Bypass 使用模式分析：

| Bypass 类型 | 0to100 | multiply | vvadd | 平均占比 |
|------------|--------|----------|-------|---------|
| EX-MEM     | 0.4%   | 29.4%    | 36.0% | 21.9%   |
| MEM-WB     | 39.8%  | 32.3%    | 28.0% | 33.4%   |
| WB         | 59.8%  | 38.3%    | 36.0% | 44.7%   |

**观察到的现象**:
1. **WB Bypass 使用最频繁**: 平均占比 44.7%，说明距离 3 条指令的依赖最常见
2. **MEM-WB Bypass 稳定**: 在三个程序中使用率相对稳定（28-40%）
3. **EX-MEM Bypass 在计算密集型程序中更重要**: multiply 和 vvadd 中使用率显著高于 0to100
4. **依赖距离分布不均**: 不同程序有不同的依赖模式，Bypass 机制需要同时支持多种距离

### 4.3 停顿周期分析

#### 理论停顿周期计算（无 Bypass）:

停顿周期的计算基于以下假设：
- **EX-MEM 依赖**（1 条指令距离）：需要停顿 2 个周期，等待数据经过 MEM→WB→写回寄存器
- **MEM-WB 依赖**（2 条指令距离）：需要停顿 1 个周期，等待数据写回寄存器
- **WB 依赖**（3 条指令距离）：理论上不需要停顿（数据已在寄存器文件中）

| 工作负载 | EX-MEM 停顿 | MEM-WB 停顿 | WB 停顿 | 总停顿周期 |
|---------|------------|------------|---------|-----------|
| 0to100  | 4          | 200        | 0       | 204       |
| multiply| 2,010      | 1,106      | 0       | 3,116     |
| vvadd   | 5,412      | 2,104      | 0       | 7,516     |

**关键洞察**:
- Bypass 机制通过避免流水线停顿，将 CPU 性能提升了 33-47%
- 停顿周期数与程序的数据依赖密度直接相关
- vvadd 的停顿周期数最多（7,516），因此 Bypass 的效果最显著

---

## 5. 理论计算说明

### 5.1 计算假设

1. **有 Bypass 的周期数**: 从日志文件中提取的实际运行周期数
2. **Bypass 使用统计**: 统计日志中不同类型 Bypass 的使用次数
3. **无 Bypass 停顿惩罚**:
   - EX-MEM Bypass → 2 个周期停顿
   - MEM-WB Bypass → 1 个周期停顿
   - WB Bypass → 0 个周期停顿
4. **无 Bypass 总周期数** = 有 Bypass 周期数 + 总停顿周期数

### 5.2 计算公式

```
总停顿周期数 = (EX-MEM Bypass 次数 × 2) + (MEM-WB Bypass 次数 × 1) + (WB Bypass 次数 × 0)
理论周期数（无 Bypass）= 实际周期数（有 Bypass）+ 总停顿周期数
性能提升周期数 = 理论周期数（无 Bypass）- 实际周期数（有 Bypass）
性能提升百分比 = (性能提升周期数 / 理论周期数（无 Bypass）) × 100%
```

### 5.3 计算示例 (0to100)

```
实际周期数（有 Bypass）= 412
EX-MEM Bypass 次数 = 2
MEM-WB Bypass 次数 = 200
WB Bypass 次数 = 301

总停顿周期数 = (2 × 2) + (200 × 1) + (301 × 0) = 4 + 200 + 0 = 204
理论周期数（无 Bypass）= 412 + 204 = 616

性能提升 = 616 - 412 = 204 周期
性能提升百分比 = (204 / 616) × 100% = 33.12%
```

---

## 6. 结论与建议

### 6.1 主要结论

1. **Bypass 机制显著提升性能**: 
   - 性能提升范围从 **33.12%** 到 **47.13%**
   - 平均性能提升约 **40%**
   - 避免了数千个周期的流水线停顿

2. **不同程序有不同的依赖模式**:
   - 0to100：以距离 2-3 的依赖为主（MEM-WB 和 WB Bypass）
   - multiply：依赖模式相对均衡，三种 Bypass 都有较高使用率
   - vvadd：性能提升最显著，说明向量运算包含最密集的数据依赖

3. **Bypass 机制对计算密集型程序更重要**:
   - vvadd 性能提升 47.13%，避免了 7,516 个周期的停顿
   - 计算密集型程序通常有更多的数据依赖，Bypass 的价值更大

4. **多级 Bypass 机制必要性**:
   - 三种 Bypass 机制都被频繁使用
   - 单一的 Bypass 机制无法处理所有依赖模式
   - 完整的 Bypass 实现需要支持 EX-MEM、MEM-WB 和 WB 三个级别

### 6.2 设计建议

1. **Bypass 机制不可或缺**: 
   - 对于现代流水线 CPU，Bypass 是必需的性能优化技术
   - 性能提升（33-47%）远超硬件实现成本

2. **优先实现 EX-MEM 和 MEM-WB Bypass**:
   - 这两种 Bypass 避免的停顿周期最多
   - EX-MEM Bypass 在计算密集型程序中尤为重要

3. **考虑负载特征优化**:
   - 不同应用有不同的依赖模式
   - 可以根据目标应用调整 Bypass 机制的实现优先级

### 6.3 总结

本次性能分析表明，Assassyn-CPU 的数据前递（Bypass）机制实现是非常成功的。相比没有 Bypass 的情况（三条指令之内有依赖就 Stall），Bypass 机制将 CPU 性能提升了 **33% 到 47%**，平均约 **40%**。

**关键数据**：
- **0to100**: 从 616 周期降低到 412 周期，节省 204 周期（33.12%）
- **multiply**: 从 7,756 周期降低到 4,640 周期，节省 3,116 周期（40.18%）
- **vvadd**: 从 15,949 周期降低到 8,433 周期，节省 7,516 周期（47.13%）

**核心发现**：
- Bypass 机制消除了流水线中的大部分数据依赖停顿
- 不同程序有不同的依赖模式，需要多级 Bypass 支持
- 计算密集型程序从 Bypass 中获益最多
- 当前的三级 Bypass 实现（EX-MEM、MEM-WB、WB）能够有效处理各种依赖距离

Bypass 机制是现代流水线 CPU 设计中不可或缺的关键技术，其性能收益远超硬件实现的复杂度成本。

---

## 7. 附录：数据来源

### 7.1 日志文件路径
- `/log/0to100_log.txt`
- `/log/multiply_log.txt`
- `/log/vvadd_log.txt`

### 7.2 原始数据
详细的性能数据保存在 `/report/bypass_performance_data.json` 文件中。

### 7.3 报告生成日期
生成时间：2025年12月17日
