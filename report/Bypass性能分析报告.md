# Assassyn-CPU 数据前递（Bypass）性能分析报告

## 1. 报告概述

本报告对比分析了 Assassyn-CPU 在启用数据前递（Bypass）机制的情况下与不启用 Bypass 之间的性能差异。通过分析三个工作负载（0to100、multiply、vvadd）的运行日志，评估 Bypass 对 CPU 性能的提升效果。

**重要说明**: 本 CPU 采用**半周期时序设计**（前半周期读，后半周期写），这意味着 WB 阶段在周期的后半部分写入寄存器堆，而下一条指令可以在下一个周期的前半部分读取，从而避免了传统全周期设计中的一个周期延迟。

**性能指标**: 程序运行的总周期数（越少越好）

---

## 2. 测试环境

### 2.1 CPU 配置
- **架构**: Assassyn-CPU 五级流水线（IF-ID-EX-MEM-WB）
- **时序设计**: **半周期时序**（前半周期读取寄存器，后半周期写入寄存器）
- **数据前递机制**: 
  - EX-MEM Bypass：EX 阶段可以直接使用 MEM 阶段的结果
  - MEM-WB Bypass：EX 阶段可以直接使用 WB 阶段的结果
  - WB Bypass：EX 阶段可以直接使用即将写回的结果
- **流水线停顿策略**（无 Bypass）：
  - 三条指令之内有依赖关系时，流水线必须停顿（Stall）
  - 停顿时间取决于依赖距离和时序设计

### 2.2 测试工作负载
1. **0to100**: 简单循环计数程序（从 0 加到 100）
2. **multiply**: 矩阵乘法运算程序
3. **vvadd**: 向量加法运算程序

---

## 3. 性能测试结果

### 3.1 总体性能对比

| 工作负载 | 有 Bypass 周期数 | 无 Bypass 周期数 | 性能提升 | 提升百分比 |
|---------|-----------------|-----------------|---------|----------|
| 0to100  | **412**         | 414             | 2       | **0.48%** |
| multiply| **4,640**       | 5,645           | 1,005   | **17.80%** |
| vvadd   | **8,433**       | 11,139          | 2,706   | **24.29%** |

**关键发现**:
- 由于采用**半周期时序设计**，Bypass 机制的性能提升相比传统全周期设计有所降低
- 性能提升范围从 **0.48%** 到 **24.29%**，平均约为 **14%**
- 只有 **EX-MEM Bypass** 真正避免停顿（节省 1 个周期），MEM-WB 和 WB Bypass 因半周期写入而不再节省周期
- Bypass 机制在数据依赖密集且依赖距离为 1 的程序中效果更明显（如 vvadd、multiply）

### 3.2 详细性能指标

#### 3.2.1 0to100 工作负载

| 指标                         | 数值     |
|-----------------------------|---------|
| 总执行周期数（有 Bypass）      | 412     |
| EX-MEM Bypass 使用次数       | 2       |
| MEM-WB Bypass 使用次数       | 200     |
| WB Bypass 使用次数           | 301     |
| 总 Bypass 使用次数           | 503     |
| 无 Bypass 总停顿周期数        | 2       |
| 理论周期数（无 Bypass）        | 414     |
| 性能提升周期数               | 2       |
| 性能提升百分比               | 0.48%   |

**分析**:
- 0to100 是简单的循环计数程序，包含大量数据依赖
- 由于半周期时序设计，只有 EX-MEM Bypass（2 次）真正避免停顿，节省 2 个周期
- MEM-WB Bypass 和 WB Bypass 虽然使用频繁（共 501 次），但因寄存器堆支持半周期写入，不再产生停顿
- 程序中大多数依赖距离为 2-3 条指令，因此性能提升有限（仅 0.48%）

#### 3.2.2 multiply 工作负载

| 指标                         | 数值      |
|-----------------------------|----------|
| 总执行周期数（有 Bypass）      | 4,640    |
| EX-MEM Bypass 使用次数       | 1,005    |
| MEM-WB Bypass 使用次数       | 1,106    |
| WB Bypass 使用次数           | 1,311    |
| 总 Bypass 使用次数           | 3,422    |
| 无 Bypass 总停顿周期数        | 1,005    |
| 理论周期数（无 Bypass）        | 5,645    |
| 性能提升周期数               | 1,005    |
| 性能提升百分比               | 17.80%   |

**分析**:
- multiply 是计算密集型程序，包含大量矩阵乘法运算
- 总共使用了 3,422 次 Bypass，但因半周期时序，只有 EX-MEM Bypass 真正避免停顿
- EX-MEM Bypass 使用 1,005 次，避免了 1,005 个周期的停顿，性能提升 17.80%
- 程序中存在大量紧密相邻的依赖关系（1 条指令距离），因此 EX-MEM Bypass 效果显著

#### 3.2.3 vvadd 工作负载

| 指标                         | 数值      |
|-----------------------------|----------|
| 总执行周期数（有 Bypass）      | 8,433    |
| EX-MEM Bypass 使用次数       | 2,706    |
| MEM-WB Bypass 使用次数       | 2,104    |
| WB Bypass 使用次数           | 2,706    |
| 总 Bypass 使用次数           | 7,516    |
| 无 Bypass 总停顿周期数        | 2,706    |
| 理论周期数（无 Bypass）        | 11,139   |
| 性能提升周期数               | 2,706    |
| 性能提升百分比               | 24.29%   |

**分析**:
- vvadd 是向量加法程序，包含大量向量元素的加法运算
- 这是性能提升最显著的工作负载，达到 **24.29%**
- 总共使用了 7,516 次 Bypass，但因半周期时序，只有 EX-MEM Bypass（2,706 次）真正避免停顿
- EX-MEM Bypass 使用 2,706 次，避免了 2,706 个周期的停顿
- 向量操作包含大量距离为 1 的依赖关系，因此 EX-MEM Bypass 效果最为显著

---

## 4. Bypass 机制分析

### 4.1 Bypass 架构特点

当前实现的 Bypass 机制在**半周期时序设计**下具有以下特点：

**半周期时序说明**：
- 寄存器堆在时钟周期的**后半部分写入**，在**前半部分读取**
- WB 阶段在 T 周期后半部分写入寄存器，下一条指令在 T+1 周期前半部分即可读取
- 这使得距离较远的依赖无需 Bypass 即可避免停顿

**Bypass 类型与停顿避免**：
- **EX-MEM Bypass**: 允许 EX 阶段直接获取 MEM 阶段的计算结果
  - 避免停顿周期数：**1 个周期**（半周期时序下）
  - 适用于相邻指令的依赖关系（距离 1 条指令）
  - **这是唯一真正节省周期的 Bypass**
- **MEM-WB Bypass**: 允许 EX 阶段直接获取 WB 阶段的结果
  - 避免停顿周期数：**0 个周期**（因半周期写入而无需停顿）
  - 适用于距离 2 条指令的依赖关系
  - 提供正确的数据路由，但不节省周期
- **WB Bypass**: 允许 EX 阶段直接获取即将写回寄存器的结果
  - 避免停顿周期数：**0 个周期**
  - 适用于距离 3 条指令的依赖关系
  - 提供正确的数据路由，但不节省周期

### 4.2 Bypass 效能评估

#### 优势：
1. **针对性的性能提升**: EX-MEM Bypass 为计算密集型程序提供 0.48%-24.29% 的性能提升
2. **半周期时序的优势**: MEM-WB 和 WB Bypass 无需额外硬件即可提供正确数据，不产生停顿
3. **适应不同依赖模式**: 三种 Bypass 机制可以处理不同距离的数据依赖
4. **架构优化成功**: 半周期时序设计大幅降低了 Bypass 的必要性，简化了流水线控制

#### Bypass 使用模式分析：

| Bypass 类型 | 0to100 | multiply | vvadd | 平均占比 | 实际节省周期 |
|------------|--------|----------|-------|---------|-------------|
| EX-MEM     | 0.4%   | 29.4%    | 36.0% | 21.9%   | **1 周期/次** |
| MEM-WB     | 39.8%  | 32.3%    | 28.0% | 33.4%   | **0 周期/次** |
| WB         | 59.8%  | 38.3%    | 36.0% | 44.7%   | **0 周期/次** |


**关键洞察**:
- **半周期时序是关键**: 使得 MEM-WB 和 WB Bypass 无需真正避免停顿
- **EX-MEM Bypass 最重要**: 这是唯一真正节省周期的 Bypass 类型（每次节省 1 周期）
- **依赖距离影响性能**: 距离为 1 的依赖（EX-MEM）最影响性能，vvadd 中 EX-MEM 使用 2,706 次，提升 24.29%
- **0to100 收益最小**: 因为依赖距离主要为 2-3（MEM-WB/WB），只有 2 次 EX-MEM Bypass，提升仅 0.48%

---

## 5. 理论计算说明

### 5.1 计算假设

1. **有 Bypass 的周期数**: 从日志文件中提取的实际运行周期数
2. **Bypass 使用统计**: 统计日志中不同类型 Bypass 的使用次数
3. **半周期时序下的停顿惩罚**:
   - EX-MEM Bypass → **1 个周期停顿**（相邻指令依赖）
   - MEM-WB Bypass → **0 个周期停顿**（半周期写入已避免）
   - WB Bypass → **0 个周期停顿**（半周期写入已避免）
4. **无 Bypass 总周期数** = 有 Bypass 周期数 + 总停顿周期数

**半周期时序的影响**:
- 传统设计中，寄存器在整个时钟周期末尾写入，需要等到下一个周期才能读取
- 半周期设计中，寄存器在周期后半部分写入，下一周期前半部分即可读取
- 因此，距离 ≥2 的依赖（MEM-WB, WB）无需 Bypass 即可避免停顿
- 只有距离 =1 的依赖（EX-MEM）需要 Bypass 来避免 1 个周期的停顿

### 5.2 计算公式

**半周期时序设计下**:
```
总停顿周期数 = (EX-MEM Bypass 次数 × 1) + (MEM-WB Bypass 次数 × 0) + (WB Bypass 次数 × 0)
            = EX-MEM Bypass 次数
理论周期数（无 Bypass）= 实际周期数（有 Bypass）+ 总停顿周期数
性能提升周期数 = 总停顿周期数
性能提升百分比 = (性能提升周期数 / 理论周期数（无 Bypass）) × 100%
```

**对比传统全周期设计**:
```
传统设计总停顿 = (EX-MEM × 2) + (MEM-WB × 1) + (WB × 0)
半周期设计总停顿 = (EX-MEM × 1) + (MEM-WB × 0) + (WB × 0)
节省的停顿周期 = (EX-MEM × 1) + (MEM-WB × 1)
```

---

## 6. 总结

1. **半周期时序设计的关键作用**: 
   - 半周期时序使得 MEM-WB 和 WB Bypass 无需真正避免停顿
   - 性能提升范围从 **0.48%** 到 **24.29%**，平均约 **14%**
   - 只有 EX-MEM Bypass 真正避免流水线停顿（每次节省 1 周期）

2. **不同程序有不同的依赖模式**:
   - 0to100：以距离 2-3 的依赖为主（MEM-WB 和 WB），EX-MEM 仅 2 次，提升仅 0.48%
   - multiply：包含 1,005 次 EX-MEM Bypass，避免 1,005 周期停顿，提升 17.80%
   - vvadd：包含 2,706 次 EX-MEM Bypass，避免 2,706 周期停顿，提升 24.29%

3. **EX-MEM Bypass 是性能关键**:
   - vvadd 有 2,706 次相邻依赖，性能提升 24.29%
   - multiply 有 1,005 次相邻依赖，性能提升 17.80%
   - 0to100 仅有 2 次相邻依赖，性能提升仅 0.48%
   - **相邻依赖（距离 1）是主要的性能瓶颈**

4. **架构设计的成功之处**:
   - 半周期时序设计大幅降低了 Bypass 的必要性
   - MEM-WB 和 WB Bypass 虽然频繁使用（提供正确数据路由），但不产生停顿
   - 硬件实现相对简单，只有 EX-MEM Bypass 需要真正的性能优化
   - 完整的三级 Bypass 保证了数据正确性，同时半周期时序提供了性能优势

5. **对比传统全周期设计**:
   - 传统设计下的理论提升：0to100 (33.12%), multiply (40.18%), vvadd (47.13%)
   - 半周期设计下的实际提升：0to100 (0.48%), multiply (17.80%), vvadd (24.29%)
   - **半周期时序本身就避免了大量停顿，是比 Bypass 更根本的优化**

本次性能分析表明，Assassyn-CPU 采用的**半周期时序设计**是一个非常成功的架构决策。它使得数据前递（Bypass）机制的必要性大幅降低，只有 EX-MEM Bypass 真正需要避免停顿。相比没有 Bypass 的情况，EX-MEM Bypass 将 CPU 性能提升了 **0.48% 到 24.29%**，平均约 **14%**。

**关键数据（半周期时序设计）**：
- **0to100**: 从 414 周期降低到 412 周期，节省 2 周期（0.48%）
- **multiply**: 从 5,645 周期降低到 4,640 周期，节省 1,005 周期（17.80%）
- **vvadd**: 从 11,139 周期降低到 8,433 周期，节省 2,706 周期（24.29%）

**架构洞察**：
- 半周期时序设计本身比 Bypass 更重要，它避免了传统设计中的大量停顿
- 如果采用传统全周期设计，理论上需要额外停顿：0to100 (+202 周期), multiply (+2,111 周期), vvadd (+4,810 周期)
- **半周期时序 + EX-MEM Bypass 的组合**，在保持硬件简洁性的同时，达到了接近理想的流水线性能
