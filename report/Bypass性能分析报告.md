# Assassyn-CPU 数据前递（Bypass）性能分析报告

## 1. 报告概述

本报告对比分析了 Assassyn-CPU 在启用数据前递（Bypass）机制的情况下与不启用 Bypass 之间的性能差异。通过分析三个工作负载（0to100、multiply、vvadd）的运行日志，评估 Bypass 对 CPU 性能的提升效果。

**性能指标**: 程序运行的总周期数（越少越好）

---

## 2. 测试环境

### 2.1 CPU 配置
- **架构**: Assassyn-CPU 五级流水线（IF-ID-EX-MEM-WB）
- **数据前递机制**: 
  - EX-MEM Bypass：EX 阶段可以直接使用 MEM 阶段的结果
  - MEM-WB Bypass：EX 阶段可以直接使用 WB 阶段的结果
  - WB Bypass：EX 阶段可以直接使用即将写回的结果
- **流水线停顿策略**（无 Bypass）：
  - 三条指令之内有依赖关系时，流水线必须停顿（Stall）
  - 停顿时间取决于依赖距离和寄存器文件读写特性

### 2.2 测试工作负载
1. **0to100**: 简单循环计数程序（从 0 加到 100）
2. **multiply**: 矩阵乘法运算程序
3. **vvadd**: 向量加法运算程序

---

## 3. 性能测试结果

### 3.1 总体性能对比

| 工作负载 | 有 Bypass 周期数 | 无 Bypass 周期数 | 性能提升 | 提升百分比 |
|---------|-----------------|-----------------|---------|----------|
| 0to100  | **412**         | 1,119           | 707     | **63.18%** |
| multiply| **4,640**       | 11,178          | 6,538   | **58.49%** |
| vvadd   | **8,433**       | 23,465          | 15,032  | **64.06%** |

**关键发现**:
- 使用 Bypass 后，所有三个工作负载的性能均得到**极为显著的提升**
- 性能提升范围从 **58%** 到 **64%**，平均约为 **62%**
- 由于寄存器文件不支持同周期写后读，所有 Bypass 机制（包括 WB Bypass）都能避免至少一个周期的停顿
- Bypass 机制在数据依赖密集的程序中效果更明显（如 vvadd）

### 3.2 详细性能指标

#### 3.2.1 0to100 工作负载

| 指标                         | 数值     |
|-----------------------------|---------|
| 总执行周期数（有 Bypass）      | 412     |
| EX-MEM Bypass 使用次数       | 2       |
| MEM-WB Bypass 使用次数       | 200     |
| WB Bypass 使用次数           | 301     |
| 总 Bypass 使用次数           | 503     |
| 无 Bypass 总停顿周期数        | 707     |
| 理论周期数（无 Bypass）        | 1,119   |
| 性能提升周期数               | 707     |
| 性能提升百分比               | 63.18%  |

**分析**:
- 0to100 是简单的循环计数程序，包含大量数据依赖
- Bypass 机制避免了 707 个周期的停顿，性能提升 63.18%
- MEM-WB Bypass 和 WB Bypass 使用频繁（共 501 次），说明程序中大多数依赖距离为 2-3 条指令

#### 3.2.2 multiply 工作负载

| 指标                         | 数值      |
|-----------------------------|----------|
| 总执行周期数（有 Bypass）      | 4,640    |
| EX-MEM Bypass 使用次数       | 1,005    |
| MEM-WB Bypass 使用次数       | 1,106    |
| WB Bypass 使用次数           | 1,311    |
| 总 Bypass 使用次数           | 3,422    |
| 无 Bypass 总停顿周期数        | 6,538    |
| 理论周期数（无 Bypass）        | 11,178   |
| 性能提升周期数               | 6,538    |
| 性能提升百分比               | 58.49%   |

**分析**:
- multiply 是计算密集型程序，包含大量矩阵乘法运算
- 总共使用了 3,422 次 Bypass，避免了 6,538 个周期的停顿
- 性能提升 58.49%，说明矩阵乘法中存在密集的数据依赖
- EX-MEM Bypass 使用 1,005 次，说明存在大量紧密相邻的依赖关系（1 条指令距离）

#### 3.2.3 vvadd 工作负载

| 指标                         | 数值      |
|-----------------------------|----------|
| 总执行周期数（有 Bypass）      | 8,433    |
| EX-MEM Bypass 使用次数       | 2,706    |
| MEM-WB Bypass 使用次数       | 2,104    |
| WB Bypass 使用次数           | 2,706    |
| 总 Bypass 使用次数           | 7,516    |
| 无 Bypass 总停顿周期数        | 15,032   |
| 理论周期数（无 Bypass）        | 23,465   |
| 性能提升周期数               | 15,032   |
| 性能提升百分比               | 64.06%   |

**分析**:
- vvadd 是向量加法程序，包含大量向量元素的加法运算
- 这是性能提升最显著的工作负载，达到 **64.06%**
- 总共使用了 7,516 次 Bypass，避免了 15,032 个周期的停顿
- EX-MEM Bypass 和 WB Bypass 各使用 2,706 次，说明存在大量距离为 1 和 3 的依赖关系
- 向量操作的特点导致了非常密集的数据依赖模式

---

## 4. Bypass 机制分析

### 4.1 Bypass 架构特点

当前实现的 Bypass 机制具有以下特点：

- **EX-MEM Bypass**: 允许 EX 阶段直接获取 MEM 阶段的计算结果
  - 避免停顿周期数：**3 个周期**
  - 适用于相邻指令的依赖关系（距离 1 条指令）
  - 计算说明：无 Bypass 需等待 MEM→WB→下一周期共 3 个周期
  
- **MEM-WB Bypass**: 允许 EX 阶段直接获取 WB 阶段的结果
  - 避免停顿周期数：**2 个周期**
  - 适用于距离 2 条指令的依赖关系
  - 计算说明：无 Bypass 需等待 WB→下一周期共 2 个周期
  
- **WB Bypass**: 允许 EX 阶段直接获取即将写回寄存器的结果
  - 避免停顿周期数：**1 个周期**
  - 适用于距离 3 条指令的依赖关系
  - 计算说明：即使指令已在 WB 阶段，由于寄存器文件不支持同周期写后读，仍需等待下一周期，故 WB Bypass 可避免 1 个周期的停顿

### 4.2 Bypass 效能评估

#### 优势：
1. **极为显著的性能提升**: 所有工作负载的性能提升都在 58% 以上，平均约 62%
2. **消除大量停顿**: Bypass 机制避免了数千甚至上万个周期的流水线停顿
3. **适应不同依赖模式**: 三种 Bypass 机制可以处理不同距离的数据依赖
4. **硬件开销合理**: 相比性能提升，Bypass 的硬件实现成本是合理的

#### Bypass 使用模式分析：

| Bypass 类型 | 0to100 | multiply | vvadd | 平均占比 |
|------------|--------|----------|-------|---------|
| EX-MEM     | 0.4%   | 29.4%    | 36.0% | 21.9%   |
| MEM-WB     | 39.8%  | 32.3%    | 28.0% | 33.4%   |
| WB         | 59.8%  | 38.3%    | 36.0% | 44.7%   |

#### Bypass 停顿贡献分析（修正后）：

| Bypass 类型 | 0to100 停顿贡献 | multiply 停顿贡献 | vvadd 停顿贡献 |
|------------|----------------|------------------|---------------|
| EX-MEM     | 6 (0.8%)       | 3,015 (46.1%)    | 8,118 (54.0%) |
| MEM-WB     | 400 (56.6%)    | 2,212 (33.8%)    | 4,208 (28.0%) |
| WB         | 301 (42.6%)    | 1,311 (20.1%)    | 2,706 (18.0%) |
| **总计**   | **707**        | **6,538**        | **15,032**    |

**关键洞察**:
- Bypass 机制通过避免流水线停顿，将 CPU 性能提升了 **58-64%**
- 停顿周期数与程序的数据依赖密度直接相关
- vvadd 的停顿周期数最多（15,032），因此 Bypass 的效果最显著

---

## 5. 理论计算说明

### 5.1 计算假设

1. **有 Bypass 的周期数**: 从日志文件中提取的实际运行周期数
2. **Bypass 使用统计**: 统计日志中不同类型 Bypass 的使用次数
3. **寄存器文件特性**: Assassyn 的寄存器文件**不支持**前半周期（上升沿）写入、后半周期（下降沿）读取
4. **无 Bypass 停顿惩罚**（修正后）:
   - EX-MEM Bypass → **3 个周期停顿**（需等待 MEM→WB→下一周期）
   - MEM-WB Bypass → **2 个周期停顿**（需等待 WB→下一周期）
   - WB Bypass → **1 个周期停顿**（即使在 WB 阶段，仍需等待下一周期才能从寄存器读取）
5. **无 Bypass 总周期数** = 有 Bypass 周期数 + 总停顿周期数

### 5.2 计算公式

```
总停顿周期数 = (EX-MEM Bypass 次数 × 3) + (MEM-WB Bypass 次数 × 2) + (WB Bypass 次数 × 1)
理论周期数（无 Bypass）= 实际周期数（有 Bypass）+ 总停顿周期数
性能提升周期数 = 理论周期数（无 Bypass）- 实际周期数（有 Bypass）
性能提升百分比 = (性能提升周期数 / 理论周期数（无 Bypass）) × 100%
```

---

## 6. 总结

1. **Bypass 机制极为显著地提升性能**: 
   - 性能提升范围从 **58.49%** 到 **64.06%**
   - 平均性能提升约 **62%**
   - 避免了数千甚至上万个周期的流水线停顿

2. **不同程序有不同的依赖模式**:
   - 0to100：以距离 2-3 的依赖为主（MEM-WB 和 WB Bypass），性能提升 63.18%
   - multiply：依赖模式相对均衡，三种 Bypass 都有较高使用率，性能提升 58.49%
   - vvadd：性能提升最显著（64.06%），说明向量运算包含最密集的数据依赖

3. **Bypass 机制对计算密集型程序更重要**:
   - vvadd 性能提升 64.06%，避免了 15,032 个周期的停顿
   - 计算密集型程序通常有更多的数据依赖，Bypass 的价值更大

5. **多级 Bypass 机制必要性**:
   - 三种 Bypass 机制都被频繁使用
   - 单一的 Bypass 机制无法处理所有依赖模式
   - 完整的 Bypass 实现需要支持 EX-MEM、MEM-WB 和 WB 三个级别

本次性能分析表明，Assassyn-CPU 的数据前递（Bypass）机制实现是**成功的**。相比没有 Bypass 的情况，Bypass 机制将 CPU 性能提升了 **58% 到 64%**，平均约 **62%**。
