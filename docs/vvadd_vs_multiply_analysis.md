# vvadd vs multiply 对比分析报告 (更新版)

## 问题描述

使用 `src/main.py` 运行时：
- `multiply` 能正常结束
- `vvadd` 不能正常结束

## 程序结构分析

### 启动序列（两者相同）

```
0x0: auipc x2, 0x1000     ; x2 = PC + 0x1000 = 0x1000
0x4: addi x2, x2, 0       ; x2 = 0x1000 (栈指针)
0x8: jal x1, offset       ; x1 = 0xC (返回地址), 跳转到主函数
0xC: sb x0, -1(x0)        ; HALT 指令 (fe000fa3)
```

### vvadd 程序流程

```
0x10-0x98: 主函数
  0x10: addi x2, x2, -32    ; 分配栈帧
  0x14: sw x8, 28(x2)       ; 保存帧指针
  0x18: addi x8, x2, 32     ; 设置帧指针
  0x1C: sw x0, -20(x8)      ; i = 0
  0x20: jal x0, 84          ; 跳转到循环条件检查 (0x74)

循环体 (0x24-0x70):
  - 加载 A[i] 和 B[i]
  - 计算 C[i] = A[i] + B[i]
  - i++

循环条件 (0x74-0x7C):
  0x74: lw x14, -20(x8)     ; 加载 i
  0x78: addi x15, x0, 299   ; x15 = 299
  0x7C: bge x15, x14, -88   ; if (299 >= i) goto 0x24

退出 (0x80-0x98):
  0x80-0x8C: 加载返回值
  0x90: lw x8, 28(x2)       ; 恢复帧指针
  0x94: addi x2, x2, 32     ; 释放栈帧
  0x98: ret                  ; 返回到 x1 = 0xC
```

### multiply 程序流程

```
软件乘法函数 (0x10-0x78)
主函数 (0x7C-0x110)
  - 循环100次调用软件乘法
  - 使用 BGE 进行循环控制
  - 保存和恢复 x1 (非叶函数)
```

## 关键差异

| 特性 | vvadd | multiply |
|------|-------|----------|
| 循环次数 | 300 | 100 |
| 函数类型 | 叶函数（不保存x1） | 非叶函数（保存x1） |
| LUI指令 | 使用 | 不使用 |
| 循环体复杂度 | 简单（加法） | 复杂（函数调用） |
| 内存访问 | 多次load/store | 多次load/store |

## 指令分析

### vvadd 独有的指令类型

- **LUI (0x37)**: 用于计算数组C的基地址
  - `lui x15, 0x1000` at 0x50 和 0x80
  - 指令编码: `000017b7`

### 数组基地址计算

```
Array A: 0xAC (172 bytes = word 43)
Array B: 0x55C (1372 bytes = word 343)
Array C: 0xA0C (2572 bytes = word 643)

Array C 基地址计算:
  lui x15, 0x1000      ; x15 = 0x1000
  addi x13, x15, -1524 ; x13 = 0x1000 - 1524 = 0xA0C
```

### 循环边界

- vvadd: `bge x15, x14, -88` where x15=299
  - 循环从 i=0 到 i=299 (300次迭代)
  - 当 i=300 时，299 < 300，分支不执行，退出循环

- multiply: `bge x15, x14, -96` where x15=99
  - 循环从 i=0 到 i=99 (100次迭代)

## 已排除的问题

1. ✅ 启动序列相同
2. ✅ HALT指令编码正确 (fe000fa3)
3. ✅ 返回地址正确 (x1 = 0xC)
4. ✅ 循环边界条件正确
5. ✅ LUI/AUIPC 指令编码正确
6. ✅ 数组基地址计算正确
7. ✅ 文件格式正确 (ASCII hex)
8. ✅ BTB索引无冲突

## 可能的问题方向

1. **LUI指令执行**：vvadd使用LUI但multiply不使用，可能是LUI的实现有问题

2. **300次迭代**：更多的迭代次数可能触发某些边界情况

3. **Tournament Predictor 状态**：300次相同模式的分支可能导致预测器进入异常状态

4. **寄存器转发/冒险检测**：特定的指令序列可能触发数据冒险检测问题

## 建议调试步骤

1. 添加仿真日志，追踪LUI指令的执行结果
2. 检查循环最后几次迭代的PC和寄存器值
3. 验证函数返回时x1的值是否仍为0xC
4. 检查HALT指令是否被正确识别并触发finish()
